{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Theoretical Foundation: Governing Equations of Projectile Motion 1. Introduction Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion occurs in two dimensions: horizontal ( \\(x\\) -axis) and vertical ( \\(y\\) -axis). We derive the governing equations starting from Newton\u2019s laws of motion. 2. Equations of Motion Newton\u2019s second law states: \\[F=ma\\] For projectile motion, the only force acting on the object (neglecting air resistance) is gravity: \\[F_y=-mg,\\quad F_x=0\\] Thus, the acceleration components are: \\[a_x=0,\\quad a_y=-g\\] where \\(g\\) is the acceleration due to gravity. Using kinematic equations: 2.1 Vertical Motion Using the kinematic equations for constant acceleration, \\[v_y=v_0\\sin(\\theta)-gt\\] \\[y=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\] \ud83d\udd39 Governing Differential Equations Horizontal Motion No horizontal acceleration (ignoring air resistance). Velocity in \\(x\\) -direction remains constant: \\[\\frac{d^2x}{dt^2}=0\\] Integrating once: \\[\\frac{dx}{dt}=v_0\\cos(\\theta)\\] Integrating again: \\[x(t)=v_0\\cos(\\theta)\\cdot t\\] 3. Time of Flight The time of flight is found by solving for when the projectile returns to \\(y=0\\) : \\[0=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\] Factoring out \\(t\\) : \\[t(v_0\\sin(\\theta)-\\frac{1}{2}gt)=0\\] Ignoring the trivial solution \\(t=0\\) , we solve for \\(t\\) : \\[t=\\frac{2v_0\\sin(\\theta)}{g}\\] 4. Range of the Projectile The horizontal range is given by: \\[R=v_x\\times t_{flight}\\] Substituting \\(v_x=v_0\\cos(\\theta)\\) and \\(t_{flight}\\) : \\[R=v_0\\cos(\\theta)\\times\\frac{2v_0\\sin(\\theta)}{g}\\] Using the identity \\(2\\sin(\\theta)\\cos(\\theta)=\\sin(2\\theta)\\) , \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] 5. Maximum Height At maximum height, \\(v_y=0\\) : \\[0=v_0\\sin(\\theta)-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin(\\theta)}{g}\\] Using the vertical displacement equation: \\[h_{max}=v_0\\sin(\\theta)t_{max}-\\frac{1}{2}gt_{max}^2\\] Substituting \\(t_{max}\\) : \\[h_{max}=\\frac{v_0^2\\sin^2(\\theta)}{2g}\\] 6. Influence of Initial Conditions Initial Velocity \\(v_0\\) : Higher velocity increases both range and height. Launch Angle \\(\\theta\\) : The range is maximized at \\(\\theta=45^\\circ\\) . Gravity \\(g\\) : Higher gravity decreases range and height. 7. Conclusion These equations provide a fundamental description of projectile motion. In further analysis, we will explore numerical simulations and practical applications, including air resistance and varying terrains. Analysis of the Range in Projectile Motion 1. Introduction The horizontal range of a projectile is a crucial parameter that depends on the angle of projection, initial velocity, and gravitational acceleration. Understanding these dependencies allows for optimizing projectile motion in various real-world applications. 2. Governing Equation for Range The horizontal range \\(R\\) of a projectile launched from the ground at an initial velocity \\(v_0\\) and angle \\(\\theta\\) (assuming no air resistance) is given by: \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] where: \\(v_0\\) is the initial velocity, \\(g\\) is the acceleration due to gravity, \\(\\theta\\) is the launch angle. 3. Dependence on the Angle of Projection The function \\(R(\\theta)\\) is determined by the term \\(\\sin(2\\theta)\\) . Since the sine function has a maximum value of 1 at \\(90^\\circ\\) , the range is maximized when: \\[2\\theta=90^\\circ \\Rightarrow \\theta=45^\\circ\\] Thus, the optimal launch angle for maximum range in an idealized scenario is \\(\\theta=45^\\circ\\) . 4. Influence of Initial Velocity Since the range equation includes \\(v_0^2\\) , increasing the initial velocity directly increases the range quadratically: \\[R \\propto v_0^2\\] For example, if the initial velocity is doubled ( \\(2v_0\\) ), the range becomes: \\[R' = \\frac{(2v_0)^2\\sin(2\\theta)}{g} = 4R\\] indicating a fourfold increase in range. 5. Effect of Gravitational Acceleration Gravity inversely affects the range: \\[R \\propto \\frac{1}{g}\\] For planets with different gravitational accelerations, the range adjusts accordingly. For example, on the Moon ( \\(g_{moon} \\approx 1.625m/s^2\\) ), the same projectile would travel approximately six times farther than on Earth ( \\(g_{earth} \\approx 9.81m/s^2\\) ). 6. Graphical Representation A plot of \\(R\\) versus \\(\\theta\\) for various values of \\(v_0\\) and \\(g\\) reveals that: The function is symmetric around \\(\\theta=45^\\circ\\) . Larger \\(v_0\\) results in a higher curve. Higher \\(g\\) compresses the range. 7. Conclusion The horizontal range is highly dependent on the launch angle, initial velocity, and gravitational acceleration. The optimal angle for maximum range is \\(45^\\circ\\) in an idealized case. However, real-world factors such as air resistance, launch height, and varying gravitational fields can alter this result. Further exploration through computational simulations can refine our understanding of projectile motion in different environments. Practical Applications of Projectile Motion 1. Introduction Projectile motion plays a fundamental role in numerous real-world scenarios, from sports to engineering and astrophysics. While the idealized equations provide valuable insights, real applications often involve additional complexities such as air resistance, varying gravitational fields, and uneven terrain. 2. Projectiles in Sports Many sports rely on projectile motion for performance optimization: Basketball: The optimal shooting angle for a free throw is approximately \\(45^\\circ\\) to \\(50^\\circ\\) , depending on player height and shot distance. Soccer: Players must account for drag and spin effects (Magnus effect) when executing curved shots. Golf: Club selection and launch angle impact the carry distance, which is influenced by wind and air resistance. 3. Engineering Applications Engineers use projectile motion principles in various fields: Ballistics: Military and defense industries design projectile trajectories considering air resistance and varying gravitational fields. Structural Engineering: Understanding projectile motion is crucial for designing protective barriers and impact-resistant structures. Water Jet Cutting: Pressurized water follows parabolic motion, requiring precise calculations for cutting efficiency. 4. Space and Astrophysics In space exploration, projectile motion extends beyond Earth's gravity: Rocket Launches: Engineers optimize launch angles and thrust to maximize efficiency while escaping Earth's gravitational pull. Asteroid Deflection: Scientists calculate the trajectory of projectiles used to alter asteroid paths. Interplanetary Travel: Orbital mechanics rely on projectile motion principles, with gravity assists optimizing fuel efficiency. 5. Projectiles on Uneven Terrain When projectiles land on uneven ground, the standard range equation requires modifications: If the projectile lands at height \\(h\\) instead of the launch height, the modified range equation is: \\[R=\\frac{v_0\\cos\\theta}{g}\\left(v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}\\right)\\] where: \\(h\\) is the final landing height, \\(g\\) is gravitational acceleration, \\(v_0\\) is initial velocity, \\(\\theta\\) is the launch angle. This formula accounts for different impact points depending on terrain elevation. 6. The Role of Air Resistance In real-world applications, air resistance significantly alters projectile trajectories. The equation of motion considering drag force is: \\[m\\frac{d^2x}{dt^2} = -kv\\frac{dx}{dt}\\] \\[m\\frac{d^2y}{dt^2} = -mg - kv\\frac{dy}{dt}\\] where: \\(m\\) is the mass of the projectile, \\(k\\) is the drag coefficient, \\(v\\) is velocity. These equations require numerical solutions due to their complexity. 7. Conclusion Projectile motion is a versatile concept with applications across multiple disciplines. By incorporating factors such as air resistance, uneven terrain, and varying gravitational fields, engineers and scientists refine models for real-world accuracy. Computational simulations further enhance predictive capabilities, making projectile motion a cornerstone of physics and engineering. Python/Plot import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def projectile_motion_no_drag(v0, theta, g=9.81): \"\"\"Computes the range of projectile motion without air resistance.\"\"\" theta_rad = np.radians(theta) range_ = (v0**2 * np.sin(2 * theta_rad)) / g return range_ def projectile_motion_with_drag(v0, theta, mass, Cd, A, rho=1.225, g=9.81): \"\"\"Solves the projectile motion equations numerically with air resistance.\"\"\" theta_rad = np.radians(theta) vx0 = v0 * np.cos(theta_rad) vy0 = v0 * np.sin(theta_rad) def equations(t, y): vx, vy, x, y_pos = y v = np.sqrt(vx**2 + vy**2) drag_force = 0.5 * rho * Cd * A * v**2 ax = -drag_force * vx / (mass * v) ay = -g - (drag_force * vy / (mass * v)) return [ax, ay, vx, vy] sol = solve_ivp(equations, [0, 10], [vx0, vy0, 0, 0], max_step=0.01, events=lambda t, y: y[3]) return sol.y[2][-1] # Return final x-position (range) def plot_range_vs_angle(v0_values, drag=False): \"\"\"Plots range vs. angle for different initial speeds.\"\"\" angles = np.linspace(0, 90, 50) plt.figure(figsize=(8, 5)) for v0 in v0_values: ranges = [] for theta in angles: if drag: range_ = projectile_motion_with_drag(v0, theta, mass=0.145, Cd=0.47, A=0.0014) else: range_ = projectile_motion_no_drag(v0, theta) ranges.append(range_) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage: plot_range_vs_angle([10, 20, 30], drag=False) link: colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation-governing-equations-of-projectile-motion","text":"","title":"Theoretical Foundation: Governing Equations of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction","text":"Projectile motion describes the motion of an object under the influence of gravity, assuming no air resistance. The motion occurs in two dimensions: horizontal ( \\(x\\) -axis) and vertical ( \\(y\\) -axis). We derive the governing equations starting from Newton\u2019s laws of motion.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-equations-of-motion","text":"Newton\u2019s second law states: \\[F=ma\\] For projectile motion, the only force acting on the object (neglecting air resistance) is gravity: \\[F_y=-mg,\\quad F_x=0\\] Thus, the acceleration components are: \\[a_x=0,\\quad a_y=-g\\] where \\(g\\) is the acceleration due to gravity. Using kinematic equations:","title":"2. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-vertical-motion","text":"Using the kinematic equations for constant acceleration, \\[v_y=v_0\\sin(\\theta)-gt\\] \\[y=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\]","title":"2.1 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-differential-equations","text":"","title":"\ud83d\udd39 Governing Differential Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"No horizontal acceleration (ignoring air resistance). Velocity in \\(x\\) -direction remains constant: \\[\\frac{d^2x}{dt^2}=0\\] Integrating once: \\[\\frac{dx}{dt}=v_0\\cos(\\theta)\\] Integrating again: \\[x(t)=v_0\\cos(\\theta)\\cdot t\\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-time-of-flight","text":"The time of flight is found by solving for when the projectile returns to \\(y=0\\) : \\[0=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\] Factoring out \\(t\\) : \\[t(v_0\\sin(\\theta)-\\frac{1}{2}gt)=0\\] Ignoring the trivial solution \\(t=0\\) , we solve for \\(t\\) : \\[t=\\frac{2v_0\\sin(\\theta)}{g}\\]","title":"3. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-range-of-the-projectile","text":"The horizontal range is given by: \\[R=v_x\\times t_{flight}\\] Substituting \\(v_x=v_0\\cos(\\theta)\\) and \\(t_{flight}\\) : \\[R=v_0\\cos(\\theta)\\times\\frac{2v_0\\sin(\\theta)}{g}\\] Using the identity \\(2\\sin(\\theta)\\cos(\\theta)=\\sin(2\\theta)\\) , \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\]","title":"4. Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-maximum-height","text":"At maximum height, \\(v_y=0\\) : \\[0=v_0\\sin(\\theta)-gt_{max}\\] Solving for \\(t_{max}\\) : \\[t_{max}=\\frac{v_0\\sin(\\theta)}{g}\\] Using the vertical displacement equation: \\[h_{max}=v_0\\sin(\\theta)t_{max}-\\frac{1}{2}gt_{max}^2\\] Substituting \\(t_{max}\\) : \\[h_{max}=\\frac{v_0^2\\sin^2(\\theta)}{2g}\\]","title":"5. Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-influence-of-initial-conditions","text":"Initial Velocity \\(v_0\\) : Higher velocity increases both range and height. Launch Angle \\(\\theta\\) : The range is maximized at \\(\\theta=45^\\circ\\) . Gravity \\(g\\) : Higher gravity decreases range and height.","title":"6. Influence of Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion","text":"These equations provide a fundamental description of projectile motion. In further analysis, we will explore numerical simulations and practical applications, including air resistance and varying terrains.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range-in-projectile-motion","text":"","title":"Analysis of the Range in Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction_1","text":"The horizontal range of a projectile is a crucial parameter that depends on the angle of projection, initial velocity, and gravitational acceleration. Understanding these dependencies allows for optimizing projectile motion in various real-world applications.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-governing-equation-for-range","text":"The horizontal range \\(R\\) of a projectile launched from the ground at an initial velocity \\(v_0\\) and angle \\(\\theta\\) (assuming no air resistance) is given by: \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] where: \\(v_0\\) is the initial velocity, \\(g\\) is the acceleration due to gravity, \\(\\theta\\) is the launch angle.","title":"2. Governing Equation for Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-dependence-on-the-angle-of-projection","text":"The function \\(R(\\theta)\\) is determined by the term \\(\\sin(2\\theta)\\) . Since the sine function has a maximum value of 1 at \\(90^\\circ\\) , the range is maximized when: \\[2\\theta=90^\\circ \\Rightarrow \\theta=45^\\circ\\] Thus, the optimal launch angle for maximum range in an idealized scenario is \\(\\theta=45^\\circ\\) .","title":"3. Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-influence-of-initial-velocity","text":"Since the range equation includes \\(v_0^2\\) , increasing the initial velocity directly increases the range quadratically: \\[R \\propto v_0^2\\] For example, if the initial velocity is doubled ( \\(2v_0\\) ), the range becomes: \\[R' = \\frac{(2v_0)^2\\sin(2\\theta)}{g} = 4R\\] indicating a fourfold increase in range.","title":"4. Influence of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-effect-of-gravitational-acceleration","text":"Gravity inversely affects the range: \\[R \\propto \\frac{1}{g}\\] For planets with different gravitational accelerations, the range adjusts accordingly. For example, on the Moon ( \\(g_{moon} \\approx 1.625m/s^2\\) ), the same projectile would travel approximately six times farther than on Earth ( \\(g_{earth} \\approx 9.81m/s^2\\) ).","title":"5. Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-graphical-representation","text":"A plot of \\(R\\) versus \\(\\theta\\) for various values of \\(v_0\\) and \\(g\\) reveals that: The function is symmetric around \\(\\theta=45^\\circ\\) . Larger \\(v_0\\) results in a higher curve. Higher \\(g\\) compresses the range.","title":"6. Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion_1","text":"The horizontal range is highly dependent on the launch angle, initial velocity, and gravitational acceleration. The optimal angle for maximum range is \\(45^\\circ\\) in an idealized case. However, real-world factors such as air resistance, launch height, and varying gravitational fields can alter this result. Further exploration through computational simulations can refine our understanding of projectile motion in different environments.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-introduction_2","text":"Projectile motion plays a fundamental role in numerous real-world scenarios, from sports to engineering and astrophysics. While the idealized equations provide valuable insights, real applications often involve additional complexities such as air resistance, varying gravitational fields, and uneven terrain.","title":"1. Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-projectiles-in-sports","text":"Many sports rely on projectile motion for performance optimization: Basketball: The optimal shooting angle for a free throw is approximately \\(45^\\circ\\) to \\(50^\\circ\\) , depending on player height and shot distance. Soccer: Players must account for drag and spin effects (Magnus effect) when executing curved shots. Golf: Club selection and launch angle impact the carry distance, which is influenced by wind and air resistance.","title":"2. Projectiles in Sports"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-engineering-applications","text":"Engineers use projectile motion principles in various fields: Ballistics: Military and defense industries design projectile trajectories considering air resistance and varying gravitational fields. Structural Engineering: Understanding projectile motion is crucial for designing protective barriers and impact-resistant structures. Water Jet Cutting: Pressurized water follows parabolic motion, requiring precise calculations for cutting efficiency.","title":"3. Engineering Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-space-and-astrophysics","text":"In space exploration, projectile motion extends beyond Earth's gravity: Rocket Launches: Engineers optimize launch angles and thrust to maximize efficiency while escaping Earth's gravitational pull. Asteroid Deflection: Scientists calculate the trajectory of projectiles used to alter asteroid paths. Interplanetary Travel: Orbital mechanics rely on projectile motion principles, with gravity assists optimizing fuel efficiency.","title":"4. Space and Astrophysics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-projectiles-on-uneven-terrain","text":"When projectiles land on uneven ground, the standard range equation requires modifications: If the projectile lands at height \\(h\\) instead of the launch height, the modified range equation is: \\[R=\\frac{v_0\\cos\\theta}{g}\\left(v_0\\sin\\theta+\\sqrt{(v_0\\sin\\theta)^2+2gh}\\right)\\] where: \\(h\\) is the final landing height, \\(g\\) is gravitational acceleration, \\(v_0\\) is initial velocity, \\(\\theta\\) is the launch angle. This formula accounts for different impact points depending on terrain elevation.","title":"5. Projectiles on Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-the-role-of-air-resistance","text":"In real-world applications, air resistance significantly alters projectile trajectories. The equation of motion considering drag force is: \\[m\\frac{d^2x}{dt^2} = -kv\\frac{dx}{dt}\\] \\[m\\frac{d^2y}{dt^2} = -mg - kv\\frac{dy}{dt}\\] where: \\(m\\) is the mass of the projectile, \\(k\\) is the drag coefficient, \\(v\\) is velocity. These equations require numerical solutions due to their complexity.","title":"6. The Role of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion_2","text":"Projectile motion is a versatile concept with applications across multiple disciplines. By incorporating factors such as air resistance, uneven terrain, and varying gravitational fields, engineers and scientists refine models for real-world accuracy. Computational simulations further enhance predictive capabilities, making projectile motion a cornerstone of physics and engineering.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#pythonplot","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def projectile_motion_no_drag(v0, theta, g=9.81): \"\"\"Computes the range of projectile motion without air resistance.\"\"\" theta_rad = np.radians(theta) range_ = (v0**2 * np.sin(2 * theta_rad)) / g return range_ def projectile_motion_with_drag(v0, theta, mass, Cd, A, rho=1.225, g=9.81): \"\"\"Solves the projectile motion equations numerically with air resistance.\"\"\" theta_rad = np.radians(theta) vx0 = v0 * np.cos(theta_rad) vy0 = v0 * np.sin(theta_rad) def equations(t, y): vx, vy, x, y_pos = y v = np.sqrt(vx**2 + vy**2) drag_force = 0.5 * rho * Cd * A * v**2 ax = -drag_force * vx / (mass * v) ay = -g - (drag_force * vy / (mass * v)) return [ax, ay, vx, vy] sol = solve_ivp(equations, [0, 10], [vx0, vy0, 0, 0], max_step=0.01, events=lambda t, y: y[3]) return sol.y[2][-1] # Return final x-position (range) def plot_range_vs_angle(v0_values, drag=False): \"\"\"Plots range vs. angle for different initial speeds.\"\"\" angles = np.linspace(0, 90, 50) plt.figure(figsize=(8, 5)) for v0 in v0_values: ranges = [] for theta in angles: if drag: range_ = projectile_motion_with_drag(v0, theta, mass=0.145, Cd=0.47, A=0.0014) else: range_ = projectile_motion_no_drag(v0, theta) ranges.append(range_) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Range vs. Angle of Projection') plt.legend() plt.grid() plt.show() # Example usage: plot_range_vs_angle([10, 20, 30], drag=False) link: colab","title":"Python/Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force. \ud83d\udccc Governing Differential Equation The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force \ud83d\udd0d Small-Angle Approximation Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\] \ud83d\udcd0 Analytical Solution for Small Angles The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): $$ \\theta_h(t) = C_1e^{r_1t} + C_2e^{r_2t} $$ where \\(r_1, r_2\\) are roots of the characteristic equation: $$ r^2 + br + \\frac{g}{L} = 0 $$ Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\] \ud83c\udfaf Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\] \u26a1 Energy Behavior at Resonance The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded. \u2705 Summary The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance. Investigating the Dynamics of a Forced Damped Pendulum 2. Analysis of Dynamics In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions. \ud83d\udcca Effect of Damping Coefficient \\(b\\) The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion. \ud83d\udccf Effect of Driving Amplitude \\(A\\) The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance. \u2699\ufe0f Effect of Driving Frequency \\(\\omega\\) The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\] \ud83d\udd04 Transition Between Regular and Chaotic Motion As we vary the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the system can exhibit different types of motion: Regular Motion : For certain values of $ A $ and $ \\omega $, the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: $$ \\theta(t) = B\\cos(\\omega t - \\delta) $$ Chaotic Motion : As $ A $ increases or $ \\omega $ deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos. \ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) . \u26a1 Physical Interpretation of Transitions Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion. \u2705 Summary Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior. Investigating the Dynamics of a Forced Damped Pendulum 3. Practical Applications The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits . \ud83c\udf0d Real-World Systems with Similar Dynamics Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum. \ud83d\udd0b Energy Harvesting Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time. \ud83c\udf09 Suspension Bridges Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges. \ud83d\udca1 Oscillating Electronic Circuits In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics. \u2705 Summary Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure. Python/Plot import numpy as np import matplotlib.pyplot as plt # \ud83c\udf08 Global Parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 # \ud83c\udfa8 Colors for each scenario colors = ['#ff6f61', '#6a5acd', '#20b2aa', '#ffa500', '#d7263d'] # \ud83e\udde0 Runge-Kutta Integrator def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # \ud83d\udcc8 Plot Function def plot_phase(t, Y, title, color): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(13, 5)) fig.suptitle(title, fontsize=16, fontweight='bold', color=color) axs[0].plot(t, theta, color=color, linewidth=1.8) axs[0].set_title(\"Time Series\", fontsize=12) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"\u03b8 (rad)\") axs[0].grid(True, linestyle='--', alpha=0.6) axs[1].plot(theta, theta_dot, color=color, linewidth=1.5) axs[1].set_title(\"Phase Portrait\", fontsize=12) axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"d\u03b8/dt (rad/s)\") axs[1].grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() # \ud83c\udfaf Scenarios omega_0 = np.sqrt(g / L) Y0 = np.array([0.2, 0.0]) # 1\ufe0f\u20e3 Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_phase(t, Y, \"1) Simple Pendulum \ud83c\udf15\", colors[0]) # 2\ufe0f\u20e3 Damped Pendulum gamma = 0.3 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_phase(t, Y, \"2) Damped Pendulum \ud83c\udf0a\", colors[1]) # 3\ufe0f\u20e3 Forced (no damping) A = 1.0 omega = 0.9 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_phase(t, Y, \"3) Forced Pendulum \u26a1\", colors[2]) # 4\ufe0f\u20e3 Forced + Damped def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_phase(t, Y, \"4) Forced Damped Pendulum \ud83c\udfaf\", colors[3]) # 5\ufe0f\u20e3 Chaotic / Resonant A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_phase(t, Y, \"5) Chaotic / Resonant Pendulum \ud83d\udd25\", colors[4]) Colab Link","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by a second-order nonlinear ordinary differential equation (ODE) that models the angular displacement of a pendulum subjected to both damping and an external periodic force.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-differential-equation","text":"The general equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A\\cos(\\omega t) \\] Where: \\(\\theta(t)\\) : Angular displacement as a function of time \\(b\\) : Damping coefficient \\(g\\) : Acceleration due to gravity \\(L\\) : Length of the pendulum \\(A\\) : Amplitude of the external driving force \\(\\omega\\) : Angular frequency of the driving force he driving force","title":"\ud83d\udccc Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"Under the small-angle approximation (where \\(\\theta \\ll 1\\) ), we can linearize the sine function as follows: \\[\\sin\\theta \\approx \\theta\\] This simplification reduces the governing equation to a linear inhomogeneous ordinary differential equation (ODE) : \\[\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\]","title":"\ud83d\udd0d Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analytical-solution-for-small-angles","text":"The general solution to the linearized ODE consists of two parts: Homogeneous solution (related to natural damping): $$ \\theta_h(t) = C_1e^{r_1t} + C_2e^{r_2t} $$ where \\(r_1, r_2\\) are roots of the characteristic equation: $$ r^2 + br + \\frac{g}{L} = 0 $$ Particular solution (related to the external forcing): We assume a steady-state solution of the form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] where: The amplitude of the forced oscillation is denoted by \\(B\\) , and the phase lag due to damping is denoted by \\(\\delta\\) . The amplitude of the steady-state response is given by: \\[B=\\frac{A}{\\sqrt{\\left(\\frac{g}{L}-\\omega^2\\right)^2+(b\\omega)^2}}\\]","title":"\ud83d\udcd0 Analytical Solution for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_0=\\sqrt{\\frac{g}{L}} \\] At resonance, the system absorbs energy most efficiently from the external force, and the amplitude \\(B\\) reaches a maximum: Without damping ( \\(b=0\\) ): \\[ B\\to\\infty\\quad\\text{as}\\quad\\omega\\to\\omega_0 \\] With damping: \\[ B_{\\text{max}}=\\frac{A}{b\\omega_0} \\] This finite maximum occurs at a slightly shifted resonance frequency: \\[ \\omega_{\\text{res}}=\\sqrt{\\omega_0^2-\\frac{b^2}{2}} \\]","title":"\ud83c\udfaf Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-behavior-at-resonance","text":"The total mechanical energy of the pendulum is the sum of kinetic and potential energy: \\[ E(t) = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 + mgL(1 - \\cos\\theta) \\] Under resonance: The system continually absorbs energy from the external force. The kinetic energy grows in the undamped case. In the damped case, energy input is balanced by dissipation: Leads to a steady-state oscillation. The energy oscillates but remains bounded.","title":"\u26a1 Energy Behavior at Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"The equation of motion combines restoring, damping, and external driving forces. Linearization using \\(\\sin\\theta \\approx \\theta\\) simplifies the analysis for small oscillations. Resonance amplifies oscillation amplitudes and affects energy flow. Damping ensures bounded energy growth even at resonance.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_1","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"In this section, we will investigate how the dynamics of the forced damped pendulum are influenced by key parameters such as the damping coefficient \\(b\\) , driving amplitude \\(A\\) , and driving frequency \\(\\omega\\) . Additionally, we will explore the transition between regular motion and chaotic behavior , and interpret the physical meaning of these transitions.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-coefficient-b","text":"The damping coefficient \\(b\\) plays a crucial role in determining the behavior of the system: For low damping ( \\(b \\to 0\\) ), the pendulum oscillates with large amplitudes, and the system is primarily influenced by the restoring force and external periodic force. For high damping ( \\(b \\to \\infty\\) ), the pendulum quickly returns to rest, and the oscillations decay exponentially. Mathematically, the solution to the damped harmonic oscillator can be written as: \\[\\theta(t) = \\theta_0 e^{-\\gamma t} \\cos(\\omega_0 t + \\delta)\\] Where: \\(\\gamma = \\frac{b}{2m}\\) is the damping coefficient. The damped frequency of oscillation is: \\[\\omega_d = \\sqrt{\\omega_0^2 - \\gamma^2}\\] The amplitude of the oscillations decays as \\(e^{-\\gamma t}\\) , and for high damping, this decay leads to the cessation of motion.","title":"\ud83d\udcca Effect of Damping Coefficient \\(b\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"The driving amplitude \\(A\\) determines how much external force is applied to the system: For small \\(A\\) , the system behaves similarly to an undriven damped pendulum, with oscillations decaying over time. For large \\(A\\) , the system enters a regime where the amplitude of oscillations can grow, especially if resonance occurs. The steady-state amplitude of the pendulum's oscillations due to external forcing is given by: \\[B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + (b\\omega)^2}}\\] As \\(A\\) increases, the system becomes more sensitive to changes in driving frequency \\(\\omega\\) , particularly near resonance.","title":"\ud83d\udccf Effect of Driving Amplitude \\(A\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"The driving frequency \\(\\omega\\) determines how quickly the external force oscillates: For \\(\\omega\\) close to \\(\\omega_0\\) (resonance) , the system absorbs energy most efficiently, leading to large oscillations. For \\(\\omega\\) far from \\(\\omega_0\\) , the system experiences weaker driving forces and smaller oscillations. The resonance condition is given by: \\[\\omega_{\\text{res}} = \\sqrt{\\omega_0^2 - \\frac{b^2}{2}}\\]","title":"\u2699\ufe0f Effect of Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-between-regular-and-chaotic-motion","text":"As we vary the damping coefficient $ b $, driving amplitude $ A $, and driving frequency $ \\omega $, the system can exhibit different types of motion: Regular Motion : For certain values of $ A $ and $ \\omega $, the pendulum exhibits periodic, stable oscillations. This occurs especially at resonance, where the system synchronizes with the external force. Stable periodic motion can be described by a sinusoidal function: $$ \\theta(t) = B\\cos(\\omega t - \\delta) $$ Chaotic Motion : As $ A $ increases or $ \\omega $ deviates from resonance, the system can enter a chaotic regime , where the motion becomes irregular and sensitive to initial conditions. Chaotic systems exhibit sensitive dependence on initial conditions, meaning that even tiny differences in initial angles or velocities can lead to vastly different behaviors over time. Lyapunov exponents measure the rate of divergence of nearby trajectories in phase space. Positive Lyapunov exponents are often used to identify chaos.","title":"\ud83d\udd04 Transition Between Regular and Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-and-poincare-sections","text":"To identify transitions between regular and chaotic motion, we use: Phase Diagrams : A plot of \\(\\theta\\) vs. \\(\\frac{d\\theta}{dt}\\) , which allows us to visualize the state of the system at any point in time. Poincar\u00e9 Sections : A method used to visualize the periodic or chaotic nature of the system by sampling the state of the system at periodic intervals. The transition to chaos can be observed in a bifurcation diagram , which plots the long-term behavior of the system as a function of \\(A\\) or \\(\\omega\\) .","title":"\ud83d\udcd0 Phase Diagrams and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physical-interpretation-of-transitions","text":"Regular motion is characterized by stable periodic oscillations, where the system's energy input and dissipation are balanced. This type of motion is often seen near resonance. Chaotic motion occurs when the system's sensitivity to initial conditions becomes dominant, and small changes in \\(A\\) , \\(\\omega\\) , or initial conditions lead to unpredictable motion. This is often observed as the system\u2019s energy becomes irregularly distributed. The damping coefficient \\(b\\) determines the rate at which energy is dissipated. As \\(b\\) increases, the system is less likely to exhibit chaos, and more likely to settle into regular motion.","title":"\u26a1 Physical Interpretation of Transitions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_1","text":"Damping coefficient \\(b\\) influences the rate at which the system loses energy, with higher values leading to faster dissipation and lower oscillation amplitudes. Driving amplitude \\(A\\) controls the magnitude of the external force, affecting how large the oscillations can grow, especially near resonance. Driving frequency \\(\\omega\\) determines how well the system resonates with the external force, with chaos emerging as the system becomes more sensitive to variations in \\(\\omega\\) . Transitions between regular and chaotic motion depend on the interplay of these parameters. As we approach or move away from resonance, we observe different types of periodic or chaotic behavior.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum_2","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The dynamics of the forced damped pendulum, as studied in previous sections, can be applied to a variety of real-world systems. These systems often exhibit similar behavior, such as oscillations, damping, and the effect of external driving forces. In this section, we will explore several practical applications of the forced damped pendulum model in different fields, including energy harvesting , suspension bridges , and oscillating electronic circuits .","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#real-world-systems-with-similar-dynamics","text":"Several real-world systems exhibit dynamics that closely resemble the behavior of a forced damped pendulum. These systems experience forces that cause oscillations, and the interaction of damping forces and external periodic forces results in complex behavior. Some examples include: Mechanical Systems : Mechanical oscillators, such as mass-spring systems, often demonstrate forced oscillations with damping, similar to the pendulum system. Biological Systems : Systems like human gait or the motion of the heart can be modeled using forced damped oscillators to understand rhythmic movements. Electrical Systems : Driven RLC circuits, where an external alternating current (AC) force drives the circuit, exhibit similar dynamics to the forced damped pendulum.","title":"\ud83c\udf0d Real-World Systems with Similar Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting","text":"Energy harvesting is the process of capturing and storing energy from environmental sources, such as vibrations, thermal gradients, or electromagnetic radiation. A common example of energy harvesting involves the use of vibrational energy harvesters , which convert mechanical vibrations into electrical energy. The forced damped pendulum model is particularly useful in designing these energy harvesters because: The driving force in an energy harvester comes from ambient vibrations, which are external periodic forces that drive oscillations in the system. The damping represents the energy dissipation due to friction or resistance in the harvester\u2019s mechanical components. The resonance condition plays a key role in maximizing the energy extraction. When the frequency of ambient vibrations matches the natural frequency of the harvester, the system oscillates with maximum amplitude, allowing for the most efficient conversion of mechanical energy into electrical energy. The power extracted from the system can be modeled as: \\[ P = \\frac{1}{2} m L^2 \\left(\\frac{d\\theta}{dt}\\right)^2 \\] Where: \\(P\\) is the power extracted from the system. \\(m\\) is the mass of the pendulum. \\(L\\) is the length of the pendulum. \\(\\theta(t)\\) is the angular displacement as a function of time.","title":"\ud83d\udd0b Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges are large, flexible structures that are susceptible to oscillations due to external forces, such as wind or traffic loads. The dynamics of the forced damped pendulum model can be applied to understand the oscillations of suspension bridges, particularly when considering: External driving forces , such as wind gusts or traffic-induced vibrations, that act as periodic forces on the bridge. Damping from the bridge\u2019s material properties, as well as from the air resistance and other frictional forces that act on the structure. Resonance between the natural frequency of the bridge and the driving frequency (e.g., wind), which can lead to large oscillations if not properly managed. In suspension bridges, resonance can be dangerous, as it can lead to large-amplitude oscillations, potentially causing structural failure. The Tacoma Narrows Bridge collapse in 1940 is a famous example of resonance-induced failure. The bridge\u2019s motion can be modeled by: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_{\\text{ext}}(t) \\] Where: \\(\\theta(t)\\) is the angular displacement of the bridge. \\(F_{\\text{ext}}(t)\\) is the external periodic driving force (e.g., wind). \\(b\\) is the damping coefficient related to the air resistance and friction. By controlling the damping coefficient and avoiding resonance, engineers can reduce the risk of catastrophic failure in suspension bridges.","title":"\ud83c\udf09 Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-electronic-circuits","text":"In electronics, RLC circuits (Resistor, Inductor, Capacitor) are commonly used to model oscillations in driven systems. A forced damped pendulum can be applied to analyze these circuits, as they exhibit similar dynamics: Driving Force : In an RLC circuit, the external driving force is the alternating current (AC) voltage that drives the system. Damping : Damping in RLC circuits is represented by the resistance \\(R\\) , which dissipates energy. Resonance : Just like in the pendulum, the circuit exhibits resonance when the driving frequency matches the natural frequency of the LC circuit. The behavior of an RLC circuit under external driving forces can be described by the following equation: \\[ L \\frac{d^2 q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_{\\text{ext}}(t) \\] Where: \\(q(t)\\) is the charge on the capacitor. \\(V_{\\text{ext}}(t)\\) is the external driving voltage. \\(L\\) is the inductance of the coil. \\(C\\) is the capacitance of the capacitor. \\(R\\) is the resistance of the circuit. At resonance, the current in the circuit can become very large, leading to potential damage if not properly controlled. The forced damped pendulum model can be used to predict and mitigate these effects by adjusting the driving frequency and damping characteristics.","title":"\ud83d\udca1 Oscillating Electronic Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary_2","text":"Energy Harvesting : The forced damped pendulum model helps design efficient vibrational energy harvesters by maximizing energy extraction at resonance. Suspension Bridges : Understanding resonance and damping in suspension bridges can prevent large amplitude oscillations and avoid structural failure due to external driving forces like wind. Oscillating Electronic Circuits : The model can also be applied to RLC circuits, where external AC voltages drive oscillations, and resonance must be carefully controlled to avoid damage. In all these systems, the principles of forced oscillations, damping, and resonance play critical roles in ensuring proper functionality and avoiding failure.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#pythonplot","text":"","title":"Python/Plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_4","text":"import numpy as np import matplotlib.pyplot as plt # \ud83c\udf08 Global Parameters dt = 0.01 t_max = 40 t = np.arange(0, t_max, dt) L = 1.0 g = 9.81 # \ud83c\udfa8 Colors for each scenario colors = ['#ff6f61', '#6a5acd', '#20b2aa', '#ffa500', '#d7263d'] # \ud83e\udde0 Runge-Kutta Integrator def runge_kutta(f, Y0, t): Y = np.zeros((len(t), 2)) Y[0] = Y0 for i in range(1, len(t)): k1 = f(t[i-1], Y[i-1]) k2 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k1) k3 = f(t[i-1] + dt/2, Y[i-1] + dt/2 * k2) k4 = f(t[i-1] + dt, Y[i-1] + dt * k3) Y[i] = Y[i-1] + dt/6 * (k1 + 2*k2 + 2*k3 + k4) return Y # \ud83d\udcc8 Plot Function def plot_phase(t, Y, title, color): theta = (Y[:, 0] + np.pi) % (2*np.pi) - np.pi theta_dot = Y[:, 1] fig, axs = plt.subplots(1, 2, figsize=(13, 5)) fig.suptitle(title, fontsize=16, fontweight='bold', color=color) axs[0].plot(t, theta, color=color, linewidth=1.8) axs[0].set_title(\"Time Series\", fontsize=12) axs[0].set_xlabel(\"Time (s)\") axs[0].set_ylabel(\"\u03b8 (rad)\") axs[0].grid(True, linestyle='--', alpha=0.6) axs[1].plot(theta, theta_dot, color=color, linewidth=1.5) axs[1].set_title(\"Phase Portrait\", fontsize=12) axs[1].set_xlabel(\"\u03b8 (rad)\") axs[1].set_ylabel(\"d\u03b8/dt (rad/s)\") axs[1].grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() # \ud83c\udfaf Scenarios omega_0 = np.sqrt(g / L) Y0 = np.array([0.2, 0.0]) # 1\ufe0f\u20e3 Simple Pendulum def simple(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta)]) Y = runge_kutta(simple, Y0, t) plot_phase(t, Y, \"1) Simple Pendulum \ud83c\udf15\", colors[0]) # 2\ufe0f\u20e3 Damped Pendulum gamma = 0.3 def damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta)]) Y = runge_kutta(damped, Y0, t) plot_phase(t, Y, \"2) Damped Pendulum \ud83c\udf0a\", colors[1]) # 3\ufe0f\u20e3 Forced (no damping) A = 1.0 omega = 0.9 def forced(t, Y): theta, theta_dot = Y return np.array([theta_dot, -omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced, Y0, t) plot_phase(t, Y, \"3) Forced Pendulum \u26a1\", colors[2]) # 4\ufe0f\u20e3 Forced + Damped def forced_damped(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(forced_damped, Y0, t) plot_phase(t, Y, \"4) Forced Damped Pendulum \ud83c\udfaf\", colors[3]) # 5\ufe0f\u20e3 Chaotic / Resonant A = 1.5 omega = 2.0 gamma = 0.1 def chaotic(t, Y): theta, theta_dot = Y return np.array([theta_dot, -gamma * theta_dot - omega_0**2 * np.sin(theta) + A * np.cos(omega * t)]) Y = runge_kutta(chaotic, Y0, t) plot_phase(t, Y, \"5) Chaotic / Resonant Pendulum \ud83d\udd25\", colors[4]) Colab Link","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Derivation of the Relationship Between Orbital Period and Orbital Radius Introduction The relationship between the orbital period ( \\(T\\) ) and the orbital radius ( \\(r\\) ) for circular orbits is a fundamental result in celestial mechanics, known as Kepler's Third Law . This law states that the square of the orbital period is proportional to the cube of the orbital radius. In this section, we will derive the mathematical expression for the orbital period in terms of the orbital radius. Step-by-Step Derivation Gravitational Force and Centripetal Force For an object in a circular orbit, the gravitational force provides the necessary centripetal force to keep the object in orbit. The gravitational force \\(F_g\\) is given by: \\[F_g = G \\cdot M \\cdot m \\cdot r^{-2}\\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object (e.g., the Sun or Earth), - \\(m\\) is the mass of the orbiting object, - \\(r\\) is the orbital radius (distance from the center of the central object). The centripetal force \\(F_c\\) required to maintain the circular motion is: \\[F_c = m \\cdot v^2 \\cdot r^{-1}\\] where \\(v\\) is the orbital velocity of the object. Equating Gravitational and Centripetal Forces Since the gravitational force provides the centripetal force, we equate the two expressions: \\[G \\cdot M \\cdot m \\cdot r^{-2} = m \\cdot v^2 \\cdot r^{-1}\\] Simplifying this equation by canceling out \\(m\\) and one factor of \\(r\\) , we get: \\[G \\cdot M \\cdot r^{-1} = v^2\\] Therefore, the orbital velocity \\(v\\) is given by: \\[v = \\sqrt{G \\cdot M \\cdot r^{-1}}\\] Relating Velocity to Orbital Period The orbital period \\(T\\) is the time it takes for the object to complete one full revolution around the central object. The distance traveled in one revolution is the circumference of the orbit, \\(C = 2 \\pi r\\) . The velocity \\(v\\) is related to the period \\(T\\) by the equation: \\[v = C \\cdot T^{-1} = 2 \\pi r \\cdot T^{-1}\\] Substituting the expression for \\(v\\) from the previous step: \\[2 \\pi r \\cdot T^{-1} = \\sqrt{G \\cdot M \\cdot r^{-1}}\\] Solving for the Orbital Period \\(T\\) Rearranging the equation to solve for \\(T\\) , we get: \\[T = 2 \\pi \\sqrt{r^3 \\cdot (G \\cdot M)^{-1}}\\] Final Expression The orbital period \\(T\\) is related to the orbital radius \\(r\\) by the equation: \\[T^2 = k \\cdot r^3\\] where \\(k\\) is a proportionality constant. This shows that the square of the orbital period is directly proportional to the cube of the orbital radius, which is a direct statement of Kepler's Third Law . Kepler's Third Law and Its Implications Kepler's Third Law, as derived above, states that for a circular orbit: \\[T^2 = \\frac{4 \\pi^2}{G \\cdot M} \\cdot r^3\\] This relationship is crucial for determining the period of orbiting objects when the mass of the central body is known. It also implies that the orbital period increases as the orbital radius increases, which is evident in the orbits of planets in our Solar System. Summary The orbital period \\(T\\) is related to the orbital radius \\(r\\) by the equation \\(T^2 = k \\cdot r^3\\) , which is a form of Kepler's Third Law. The equation derived is \\(T = 2 \\pi \\sqrt{r^3 \\cdot (G \\cdot M)^{-1}}\\) , which allows calculation of the orbital period given the radius and the mass of the central body. Discussion on the Implications for Astronomy Introduction Kepler's Third Law not only provides insight into the relationship between the orbital period and orbital radius but also has significant implications for the field of astronomy. This law plays a crucial role in calculating planetary masses, determining orbital distances, and understanding the dynamics of celestial bodies in our Solar System and beyond. Role of Kepler's Third Law in Calculating Planetary Masses and Distances Calculating Planetary Masses Kepler's Third Law can be used to estimate the mass of a central object (such as a star or planet) based on the orbital characteristics of an object orbiting it. Given the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ), we can calculate the mass \\(M\\) of the central object using the rearranged form of Kepler's Third Law: \\[M = \\frac{4 \\pi^2 \\cdot r^3}{G \\cdot T^2}\\] Example 1: Estimating the Mass of the Sun By observing the orbital period of a planet (e.g., Earth) and its distance from the Sun, we can estimate the Sun's mass. Using Earth\u2019s orbital period ( \\(T = 365.25\\) days) and radius ( \\(r = 1\\) AU), we can substitute these values into the formula above to calculate the Sun's mass. Example 2: Estimating the Mass of Jupiter Similarly, the mass of Jupiter can be determined by observing the orbital period and radius of one of its moons or artificial satellites. Calculating Orbital Distances Kepler's Third Law also allows astronomers to determine the orbital distance \\(r\\) of an object when the orbital period \\(T\\) is known. For example, by knowing the orbital period of a satellite or moon and the mass of the central body (such as a planet), we can use the rearranged equation to calculate the orbital radius: \\[r = \\left(\\frac{G \\cdot M \\cdot T^2}{4 \\pi^2}\\right)^{1/3}\\] Example: Determining the Distance of the Moon from Earth By measuring the orbital period of the Moon around Earth and knowing the mass of Earth, we can calculate the Moon's orbital distance using the formula above. Extrapolating to Exoplanets Kepler's Third Law has been instrumental in the discovery of exoplanets, planets orbiting stars outside our Solar System. By observing the orbital periods and distances of exoplanets, we can estimate the masses of the stars they orbit. This allows for the classification of stars based on their masses and the characterization of planetary systems. Example: Kepler Mission The Kepler Space Telescope used this principle to detect thousands of exoplanets by measuring their orbital periods and distances from their parent stars, leading to the discovery of many potentially habitable planets. Importance of Kepler's Law for Understanding Celestial Mechanics Understanding Planetary Motions Kepler\u2019s Laws, especially the Third Law, form the foundation for understanding the motions of planets and other celestial bodies. The relationship between orbital period and radius provides a tool for calculating and predicting the behavior of celestial objects. This understanding is essential not only for studying planetary systems but also for understanding the dynamics of binary star systems, moons, and satellites orbiting planets. Orbit Determination for Space Missions Kepler's Third Law is fundamental to space mission planning, including calculating the correct orbital paths for satellites, spacecraft, and probes. The equation provides the basis for calculating fuel requirements, mission durations, and rendezvous points for interplanetary missions. For example, calculating the orbit of a spacecraft to rendezvous with a planet or moon relies on the principles of orbital mechanics, of which Kepler's Laws are a key component. Orbital Resonances and Gravitational Interactions Kepler's Third Law helps explain the phenomenon of orbital resonances , where two orbiting bodies exert regular, periodic gravitational influences on each other. These resonances are important in understanding the dynamics of moons and planets within a system. An example of this is the resonance between Jupiter\u2019s moons Io, Europa, and Ganymede, which leads to periodic tidal heating of the moons. Gravitational Interactions Between Celestial Bodies Understanding the relationship between orbital period and radius helps astronomers predict the gravitational interactions between objects. For example, the gravitational influence of one planet on another can alter their orbital characteristics over time. This principle is also crucial in understanding phenomena like planetary migrations, where a planet\u2019s orbit may change due to the gravitational pull of nearby objects. Summary of Key Points Kepler's Third Law plays a key role in calculating the mass of central objects and determining the orbital distance of orbiting objects. The law is widely used to estimate the masses of stars, planets, and moons, as well as to calculate the orbital radii of objects in various celestial systems. Kepler\u2019s Laws are fundamental to our understanding of planetary motions , space mission planning , and the gravitational interactions between celestial bodies. The law also provides insights into orbital resonances and the long-term dynamics of planetary and satellite systems. Analysis of Real-World Examples Introduction Kepler's Third Law provides a fundamental tool for understanding the orbital characteristics of various celestial bodies. In this section, we will analyze the orbits of the Moon around Earth and the orbits of planets in the Solar System. We will also discuss how the relationship between orbital period and radius applies to different celestial bodies. Analysis of the Moon's Orbit Around Earth Orbital Parameters of the Moon The Moon's orbit around Earth is almost circular with the following parameters: Orbital period ( \\(T\\) ): 27.3 days Orbital radius ( \\(r\\) ): 384,400 km (distance from the center of the Earth to the center of the Moon) Application of Kepler's Third Law Using Kepler's Third Law, we can estimate the mass of Earth based on the Moon's orbit. The formula we use is: \\[T^2 = \\frac{4 \\pi^2 r^3}{G M}\\] Rearranging to solve for Earth's mass ( \\(M\\) ): \\[M = \\frac{4 \\pi^2 r^3}{G T^2}\\] Substituting the known values: - \\(r = 384,400\\) km \\(= 3.844 \\times 10^8\\) m \\(T = 27.3\\) days \\(= 2.358 \\times 10^6\\) s \\(G = 6.674 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 We can compute Earth's mass using this equation. Implications The Moon\u2019s orbital period and radius allow astronomers to calculate the mass of the Earth with high precision. This relationship is critical for understanding tidal interactions and other dynamical effects between the Earth and the Moon. Examination of the Orbits of Planets in the Solar System Orbital Parameters of Planets The orbits of planets in the Solar System are elliptical, but for simplicity, we can approximate them as circular for most practical purposes. Below are some key orbital parameters: Earth: Orbital period ( \\(T\\) ): 365.25 days Orbital radius ( \\(r\\) ): 1 AU \\(= 1.496 \\times 10^{11}\\) m Mars: Orbital period ( \\(T\\) ): 687 days Orbital radius ( \\(r\\) ): 1.524 AU \\(= 2.279 \\times 10^{11}\\) m Jupiter: Orbital period ( \\(T\\) ): 11.86 years Orbital radius ( \\(r\\) ): 5.203 AU \\(= 7.783 \\times 10^{11}\\) m Kepler's Third Law for Planetary Orbits We can apply Kepler's Third Law to calculate the masses of the Sun using the orbital data of planets. For example, using Earth\u2019s orbital data, we can estimate the mass of the Sun. The formula is: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M_{\\text{sun}}} \\] Rearranging to solve for \\(M_{\\text{sun}}\\) : \\[M_{\\text{sun}} = \\frac{4 \\pi^2 r^3}{G T^2}\\] Substituting known values for Earth: - \\(r= 1\\) AU \\(= 1.496 \\times 10^{11}\\) m - \\(T= 365.25\\) days \\(= 3.156 \\times 10^7\\) s The mass of the Sun can be calculated using this equation. Comparing Planetary Orbits From Kepler\u2019s Third Law, it is evident that planets with larger orbital radii have longer orbital periods. For example, Mars has a longer period than Earth because its orbital radius is greater. Jupiter , being further from the Sun, has a significantly longer orbital period, which is nearly 12 years. Implications By observing the orbital periods and radii of planets, we can calculate the mass of the Sun with remarkable precision. The relationship also helps in understanding the differences in orbital dynamics, such as why outer planets take longer to orbit the Sun than inner planets. Application of Kepler's Third Law to Other Celestial Bodies Satellites and Moons Kepler's Third Law is widely applied to artificial satellites orbiting Earth or other celestial bodies. For example, by knowing the orbital period and radius of a satellite, we can calculate the mass of the planet or moon it orbits. Example: International Space Station (ISS) The ISS orbits Earth with a period of about 90 minutes and an average orbital radius of approximately 400 km from the Earth's surface. By applying Kepler's Third Law, we can estimate the Earth's mass. Exoplanets and Exostellar Systems Kepler\u2019s Third Law has been crucial in the discovery and study of exoplanets \u2014planets orbiting stars outside the Solar System. By measuring the orbital periods and distances of exoplanets, astronomers can calculate the masses of the parent stars. Example: Kepler-22b Using the orbital data of Kepler-22b , an exoplanet discovered by NASA\u2019s Kepler mission, scientists can estimate the mass of the star it orbits and the planet\u2019s orbital characteristics. Comets and Asteroids The orbits of comets and asteroids can also be described using Kepler's Third Law. For example, the orbital period of Halley's Comet is about 76 years, and by applying the law, we can predict when it will return to the inner Solar System. Similarly, asteroid belts and their orbital characteristics can be studied to understand their interaction with planets and the formation of the Solar System. Summary The Moon's orbit around Earth allows us to calculate the mass of Earth and study tidal interactions. Planetary orbits in the Solar System follow Kepler's Third Law, with planets farther from the Sun having longer orbital periods. Kepler's Third Law applies to artificial satellites, exoplanets, moons, and other celestial bodies, providing a universal framework for understanding orbital dynamics. Extended Discussion on Elliptical Orbits Kepler's Laws provide a fundamental framework for understanding planetary motion. While we have mainly discussed circular orbits, Kepler's First Law states that planets move in elliptical orbits with the Sun at one focus, not in perfect circles. Let\u2019s explore how Kepler\u2019s Third Law extends to elliptical orbits and the differences between circular and elliptical orbits. 1. Kepler\u2019s Third Law for Elliptical Orbits Kepler's Third Law can still be applied to elliptical orbits, but with a slight modification. For elliptical orbits , the law states: \\[T^2=\\frac{4\\pi^2a^3}{GM}\\] Where: - \\(T\\) is the orbital period, \\(a\\) is the semi-major axis of the ellipse (the longest radius), \\(M\\) is the mass of the central body, \\(G\\) is the gravitational constant. This equation tells us that the square of the orbital period is still proportional to the cube of the semi-major axis ( \\(a\\) ) of the elliptical orbit, rather than the orbital radius ( \\(r\\) ) as in the case of circular orbits. 2. Difference Between Circular and Elliptical Orbits While both circular and elliptical orbits adhere to Kepler\u2019s Third Law, there are key differences between the two: Circular Orbits : In circular orbits, the orbital radius is constant and equal to the semi-major axis . The object\u2019s distance from the central body does not change during the orbit. The orbital period is determined solely by the radius (or semi-major axis). For circular orbits, the relationship is straightforward: \\( \\(T^2\\propto r^3\\) \\) Elliptical Orbits : In elliptical orbits, the object moves closer and farther from the central body throughout its orbit. The distance varies, and thus the orbital speed also changes. The central body is located at one of the two foci of the ellipse, and the object\u2019s distance from the focus is not constant. Despite the varying distance, the orbital period is still determined by the semi-major axis ( \\(a\\) ), not by the instantaneous distance of the orbiting body. This means that the orbital period remains the same even though the object\u2019s speed changes throughout its elliptical orbit. The orbit is longer when the object is farther from the central body (at aphelion) and shorter when it\u2019s closer (at perihelion). 3. Orbital Speed in Elliptical Orbits Unlike in circular orbits where the object\u2019s speed is constant, orbital speed in elliptical orbits varies depending on the object\u2019s distance from the central body. The object moves fastest when it is closest to the focus (at perihelion) and slowest when it is farthest from the focus (at aphelion). This behavior is explained by Kepler\u2019s Second Law , which states: Kepler\u2019s Second Law : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. This means that when a planet is closer to the Sun, it moves faster to sweep out the same area. 4. Visualizing Elliptical Orbits To better understand elliptical orbits, let\u2019s discuss the main characteristics: - Semi-major axis ( \\(a\\) ) : The longest axis of the ellipse, running from one end (aphelion) to the other (perihelion). Eccentricity ( \\(e\\) ) : A measure of how \u201cstretched out\u201d the ellipse is. An eccentricity of 0 corresponds to a perfect circle, while an eccentricity close to 1 indicates a very elongated ellipse. For an elliptical orbit, we can express the relationship between the perihelion ( \\(r_p\\) ) and aphelion ( \\(r_a\\) ) as: \\( \\(r_p=a(1-e)\\) \\) \\( \\(r_a=a(1+e)\\) \\) where \\(e\\) is the eccentricity of the ellipse. 5. Orbital Period and Elliptical Orbits In elliptical orbits, even though the distance from the central body varies, the orbital period still depends only on the semi-major axis ( \\(a\\) ). This is the key takeaway from Kepler\u2019s Third Law for elliptical orbits: the semi-major axis is the defining parameter for the orbital period, just as the orbital radius determines the period in a circular orbit. Conclusion Circular Orbits : The orbital period depends directly on the orbital radius, and the relationship is simple: \\(T^2\\propto r^3\\) . Elliptical Orbits : The orbital period depends on the semi-major axis ( \\(a\\) ) of the ellipse, and the relationship remains: \\(T^2\\propto a^3\\) . Despite the varying distance, the period is determined by the semi-major axis and remains the same for any elliptical orbit with the same semi-major axis. Differences Between Circular and Elliptical Orbits Characteristic Circular Orbits Elliptical Orbits Shape Perfect circle Ellipse (stretched circle) Orbital Radius Constant Varies (closest at perihelion, farthest at aphelion) Orbital Speed Constant Varies (fastest at perihelion, slowest at aphelion) Orbit Period Depends on radius Depends on semi-major axis (same as for circular orbits with same semi-major axis) Kepler's Third Law applies to both, but the shape and speed variation in elliptical orbits make them more complex, requiring a more thorough understanding of orbital mechanics. However, the fundamental relationship that \\(T^2\\propto a^3\\) holds true for both circular and elliptical orbits. Python/Plot import numpy as np import matplotlib.pyplot as plt # Orbital data: Semi-major axis (r) in AU, Orbital period (T) in Earth years solar_system_data = { \"Mercury\": {\"r\": 0.39, \"T\": 0.24}, \"Venus\": {\"r\": 0.72, \"T\": 0.62}, \"Earth\": {\"r\": 1.00, \"T\": 1.00}, \"Mars\": {\"r\": 1.52, \"T\": 1.88}, \"Jupiter\": {\"r\": 5.20, \"T\": 11.86}, \"Saturn\": {\"r\": 9.58, \"T\": 29.46}, \"Uranus\": {\"r\": 19.18, \"T\": 84.01}, \"Neptune\": {\"r\": 30.07, \"T\": 164.8} } # Prepare data r_cubed = [] T_squared = [] planet_names = [] for planet, values in solar_system_data.items(): r = values[\"r\"] T = values[\"T\"] r_cubed.append(r**3) T_squared.append(T**2) planet_names.append(planet) # Sorting data by r_cubed for consistent plotting sorted_data = sorted(zip(r_cubed, T_squared, planet_names)) r_cubed, T_squared, planet_names = zip(*sorted_data) # Plotting with log-log scale plt.figure(figsize=(10, 7)) plt.plot(r_cubed, T_squared, '-o', color='royalblue', linewidth=2, markersize=8) plt.xscale('log') plt.yscale('log') # Annotate for i in range(len(planet_names)): plt.annotate(planet_names[i], (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6, 4), fontsize=10, weight='bold') # Axis labels and title plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ (Log-Log Scale)\", fontsize=14, weight='bold') plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() Colab","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship-between-orbital-period-and-orbital-radius","text":"","title":"Derivation of the Relationship Between Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The relationship between the orbital period ( \\(T\\) ) and the orbital radius ( \\(r\\) ) for circular orbits is a fundamental result in celestial mechanics, known as Kepler's Third Law . This law states that the square of the orbital period is proportional to the cube of the orbital radius. In this section, we will derive the mathematical expression for the orbital period in terms of the orbital radius.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-by-step-derivation","text":"Gravitational Force and Centripetal Force For an object in a circular orbit, the gravitational force provides the necessary centripetal force to keep the object in orbit. The gravitational force \\(F_g\\) is given by: \\[F_g = G \\cdot M \\cdot m \\cdot r^{-2}\\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central object (e.g., the Sun or Earth), - \\(m\\) is the mass of the orbiting object, - \\(r\\) is the orbital radius (distance from the center of the central object). The centripetal force \\(F_c\\) required to maintain the circular motion is: \\[F_c = m \\cdot v^2 \\cdot r^{-1}\\] where \\(v\\) is the orbital velocity of the object. Equating Gravitational and Centripetal Forces Since the gravitational force provides the centripetal force, we equate the two expressions: \\[G \\cdot M \\cdot m \\cdot r^{-2} = m \\cdot v^2 \\cdot r^{-1}\\] Simplifying this equation by canceling out \\(m\\) and one factor of \\(r\\) , we get: \\[G \\cdot M \\cdot r^{-1} = v^2\\] Therefore, the orbital velocity \\(v\\) is given by: \\[v = \\sqrt{G \\cdot M \\cdot r^{-1}}\\] Relating Velocity to Orbital Period The orbital period \\(T\\) is the time it takes for the object to complete one full revolution around the central object. The distance traveled in one revolution is the circumference of the orbit, \\(C = 2 \\pi r\\) . The velocity \\(v\\) is related to the period \\(T\\) by the equation: \\[v = C \\cdot T^{-1} = 2 \\pi r \\cdot T^{-1}\\] Substituting the expression for \\(v\\) from the previous step: \\[2 \\pi r \\cdot T^{-1} = \\sqrt{G \\cdot M \\cdot r^{-1}}\\] Solving for the Orbital Period \\(T\\) Rearranging the equation to solve for \\(T\\) , we get: \\[T = 2 \\pi \\sqrt{r^3 \\cdot (G \\cdot M)^{-1}}\\]","title":"Step-by-Step Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-expression","text":"The orbital period \\(T\\) is related to the orbital radius \\(r\\) by the equation: \\[T^2 = k \\cdot r^3\\] where \\(k\\) is a proportionality constant. This shows that the square of the orbital period is directly proportional to the cube of the orbital radius, which is a direct statement of Kepler's Third Law .","title":"Final Expression"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-and-its-implications","text":"Kepler's Third Law, as derived above, states that for a circular orbit: \\[T^2 = \\frac{4 \\pi^2}{G \\cdot M} \\cdot r^3\\] This relationship is crucial for determining the period of orbiting objects when the mass of the central body is known. It also implies that the orbital period increases as the orbital radius increases, which is evident in the orbits of planets in our Solar System.","title":"Kepler's Third Law and Its Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"The orbital period \\(T\\) is related to the orbital radius \\(r\\) by the equation \\(T^2 = k \\cdot r^3\\) , which is a form of Kepler's Third Law. The equation derived is \\(T = 2 \\pi \\sqrt{r^3 \\cdot (G \\cdot M)^{-1}}\\) , which allows calculation of the orbital period given the radius and the mass of the central body.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion-on-the-implications-for-astronomy","text":"","title":"Discussion on the Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction_1","text":"Kepler's Third Law not only provides insight into the relationship between the orbital period and orbital radius but also has significant implications for the field of astronomy. This law plays a crucial role in calculating planetary masses, determining orbital distances, and understanding the dynamics of celestial bodies in our Solar System and beyond.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#role-of-keplers-third-law-in-calculating-planetary-masses-and-distances","text":"Calculating Planetary Masses Kepler's Third Law can be used to estimate the mass of a central object (such as a star or planet) based on the orbital characteristics of an object orbiting it. Given the orbital period ( \\(T\\) ) and orbital radius ( \\(r\\) ), we can calculate the mass \\(M\\) of the central object using the rearranged form of Kepler's Third Law: \\[M = \\frac{4 \\pi^2 \\cdot r^3}{G \\cdot T^2}\\] Example 1: Estimating the Mass of the Sun By observing the orbital period of a planet (e.g., Earth) and its distance from the Sun, we can estimate the Sun's mass. Using Earth\u2019s orbital period ( \\(T = 365.25\\) days) and radius ( \\(r = 1\\) AU), we can substitute these values into the formula above to calculate the Sun's mass. Example 2: Estimating the Mass of Jupiter Similarly, the mass of Jupiter can be determined by observing the orbital period and radius of one of its moons or artificial satellites. Calculating Orbital Distances Kepler's Third Law also allows astronomers to determine the orbital distance \\(r\\) of an object when the orbital period \\(T\\) is known. For example, by knowing the orbital period of a satellite or moon and the mass of the central body (such as a planet), we can use the rearranged equation to calculate the orbital radius: \\[r = \\left(\\frac{G \\cdot M \\cdot T^2}{4 \\pi^2}\\right)^{1/3}\\] Example: Determining the Distance of the Moon from Earth By measuring the orbital period of the Moon around Earth and knowing the mass of Earth, we can calculate the Moon's orbital distance using the formula above. Extrapolating to Exoplanets Kepler's Third Law has been instrumental in the discovery of exoplanets, planets orbiting stars outside our Solar System. By observing the orbital periods and distances of exoplanets, we can estimate the masses of the stars they orbit. This allows for the classification of stars based on their masses and the characterization of planetary systems. Example: Kepler Mission The Kepler Space Telescope used this principle to detect thousands of exoplanets by measuring their orbital periods and distances from their parent stars, leading to the discovery of many potentially habitable planets.","title":"Role of Kepler's Third Law in Calculating Planetary Masses and Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#importance-of-keplers-law-for-understanding-celestial-mechanics","text":"Understanding Planetary Motions Kepler\u2019s Laws, especially the Third Law, form the foundation for understanding the motions of planets and other celestial bodies. The relationship between orbital period and radius provides a tool for calculating and predicting the behavior of celestial objects. This understanding is essential not only for studying planetary systems but also for understanding the dynamics of binary star systems, moons, and satellites orbiting planets. Orbit Determination for Space Missions Kepler's Third Law is fundamental to space mission planning, including calculating the correct orbital paths for satellites, spacecraft, and probes. The equation provides the basis for calculating fuel requirements, mission durations, and rendezvous points for interplanetary missions. For example, calculating the orbit of a spacecraft to rendezvous with a planet or moon relies on the principles of orbital mechanics, of which Kepler's Laws are a key component. Orbital Resonances and Gravitational Interactions Kepler's Third Law helps explain the phenomenon of orbital resonances , where two orbiting bodies exert regular, periodic gravitational influences on each other. These resonances are important in understanding the dynamics of moons and planets within a system. An example of this is the resonance between Jupiter\u2019s moons Io, Europa, and Ganymede, which leads to periodic tidal heating of the moons. Gravitational Interactions Between Celestial Bodies Understanding the relationship between orbital period and radius helps astronomers predict the gravitational interactions between objects. For example, the gravitational influence of one planet on another can alter their orbital characteristics over time. This principle is also crucial in understanding phenomena like planetary migrations, where a planet\u2019s orbit may change due to the gravitational pull of nearby objects.","title":"Importance of Kepler's Law for Understanding Celestial Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary-of-key-points","text":"Kepler's Third Law plays a key role in calculating the mass of central objects and determining the orbital distance of orbiting objects. The law is widely used to estimate the masses of stars, planets, and moons, as well as to calculate the orbital radii of objects in various celestial systems. Kepler\u2019s Laws are fundamental to our understanding of planetary motions , space mission planning , and the gravitational interactions between celestial bodies. The law also provides insights into orbital resonances and the long-term dynamics of planetary and satellite systems.","title":"Summary of Key Points"},{"location":"1%20Physics/2%20Gravity/Problem_1/#analysis-of-real-world-examples","text":"","title":"Analysis of Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction_2","text":"Kepler's Third Law provides a fundamental tool for understanding the orbital characteristics of various celestial bodies. In this section, we will analyze the orbits of the Moon around Earth and the orbits of planets in the Solar System. We will also discuss how the relationship between orbital period and radius applies to different celestial bodies.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#analysis-of-the-moons-orbit-around-earth","text":"Orbital Parameters of the Moon The Moon's orbit around Earth is almost circular with the following parameters: Orbital period ( \\(T\\) ): 27.3 days Orbital radius ( \\(r\\) ): 384,400 km (distance from the center of the Earth to the center of the Moon) Application of Kepler's Third Law Using Kepler's Third Law, we can estimate the mass of Earth based on the Moon's orbit. The formula we use is: \\[T^2 = \\frac{4 \\pi^2 r^3}{G M}\\] Rearranging to solve for Earth's mass ( \\(M\\) ): \\[M = \\frac{4 \\pi^2 r^3}{G T^2}\\] Substituting the known values: - \\(r = 384,400\\) km \\(= 3.844 \\times 10^8\\) m \\(T = 27.3\\) days \\(= 2.358 \\times 10^6\\) s \\(G = 6.674 \\times 10^{-11}\\) m\u00b3/kg/s\u00b2 We can compute Earth's mass using this equation. Implications The Moon\u2019s orbital period and radius allow astronomers to calculate the mass of the Earth with high precision. This relationship is critical for understanding tidal interactions and other dynamical effects between the Earth and the Moon.","title":"Analysis of the Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#examination-of-the-orbits-of-planets-in-the-solar-system","text":"Orbital Parameters of Planets The orbits of planets in the Solar System are elliptical, but for simplicity, we can approximate them as circular for most practical purposes. Below are some key orbital parameters: Earth: Orbital period ( \\(T\\) ): 365.25 days Orbital radius ( \\(r\\) ): 1 AU \\(= 1.496 \\times 10^{11}\\) m Mars: Orbital period ( \\(T\\) ): 687 days Orbital radius ( \\(r\\) ): 1.524 AU \\(= 2.279 \\times 10^{11}\\) m Jupiter: Orbital period ( \\(T\\) ): 11.86 years Orbital radius ( \\(r\\) ): 5.203 AU \\(= 7.783 \\times 10^{11}\\) m Kepler's Third Law for Planetary Orbits We can apply Kepler's Third Law to calculate the masses of the Sun using the orbital data of planets. For example, using Earth\u2019s orbital data, we can estimate the mass of the Sun. The formula is: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M_{\\text{sun}}} \\] Rearranging to solve for \\(M_{\\text{sun}}\\) : \\[M_{\\text{sun}} = \\frac{4 \\pi^2 r^3}{G T^2}\\] Substituting known values for Earth: - \\(r= 1\\) AU \\(= 1.496 \\times 10^{11}\\) m - \\(T= 365.25\\) days \\(= 3.156 \\times 10^7\\) s The mass of the Sun can be calculated using this equation. Comparing Planetary Orbits From Kepler\u2019s Third Law, it is evident that planets with larger orbital radii have longer orbital periods. For example, Mars has a longer period than Earth because its orbital radius is greater. Jupiter , being further from the Sun, has a significantly longer orbital period, which is nearly 12 years. Implications By observing the orbital periods and radii of planets, we can calculate the mass of the Sun with remarkable precision. The relationship also helps in understanding the differences in orbital dynamics, such as why outer planets take longer to orbit the Sun than inner planets.","title":"Examination of the Orbits of Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#application-of-keplers-third-law-to-other-celestial-bodies","text":"Satellites and Moons Kepler's Third Law is widely applied to artificial satellites orbiting Earth or other celestial bodies. For example, by knowing the orbital period and radius of a satellite, we can calculate the mass of the planet or moon it orbits. Example: International Space Station (ISS) The ISS orbits Earth with a period of about 90 minutes and an average orbital radius of approximately 400 km from the Earth's surface. By applying Kepler's Third Law, we can estimate the Earth's mass. Exoplanets and Exostellar Systems Kepler\u2019s Third Law has been crucial in the discovery and study of exoplanets \u2014planets orbiting stars outside the Solar System. By measuring the orbital periods and distances of exoplanets, astronomers can calculate the masses of the parent stars. Example: Kepler-22b Using the orbital data of Kepler-22b , an exoplanet discovered by NASA\u2019s Kepler mission, scientists can estimate the mass of the star it orbits and the planet\u2019s orbital characteristics. Comets and Asteroids The orbits of comets and asteroids can also be described using Kepler's Third Law. For example, the orbital period of Halley's Comet is about 76 years, and by applying the law, we can predict when it will return to the inner Solar System. Similarly, asteroid belts and their orbital characteristics can be studied to understand their interaction with planets and the formation of the Solar System.","title":"Application of Kepler's Third Law to Other Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary_1","text":"The Moon's orbit around Earth allows us to calculate the mass of Earth and study tidal interactions. Planetary orbits in the Solar System follow Kepler's Third Law, with planets farther from the Sun having longer orbital periods. Kepler's Third Law applies to artificial satellites, exoplanets, moons, and other celestial bodies, providing a universal framework for understanding orbital dynamics.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extended-discussion-on-elliptical-orbits","text":"Kepler's Laws provide a fundamental framework for understanding planetary motion. While we have mainly discussed circular orbits, Kepler's First Law states that planets move in elliptical orbits with the Sun at one focus, not in perfect circles. Let\u2019s explore how Kepler\u2019s Third Law extends to elliptical orbits and the differences between circular and elliptical orbits.","title":"Extended Discussion on Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-keplers-third-law-for-elliptical-orbits","text":"Kepler's Third Law can still be applied to elliptical orbits, but with a slight modification. For elliptical orbits , the law states: \\[T^2=\\frac{4\\pi^2a^3}{GM}\\] Where: - \\(T\\) is the orbital period, \\(a\\) is the semi-major axis of the ellipse (the longest radius), \\(M\\) is the mass of the central body, \\(G\\) is the gravitational constant. This equation tells us that the square of the orbital period is still proportional to the cube of the semi-major axis ( \\(a\\) ) of the elliptical orbit, rather than the orbital radius ( \\(r\\) ) as in the case of circular orbits.","title":"1. Kepler\u2019s Third Law for Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-difference-between-circular-and-elliptical-orbits","text":"While both circular and elliptical orbits adhere to Kepler\u2019s Third Law, there are key differences between the two: Circular Orbits : In circular orbits, the orbital radius is constant and equal to the semi-major axis . The object\u2019s distance from the central body does not change during the orbit. The orbital period is determined solely by the radius (or semi-major axis). For circular orbits, the relationship is straightforward: \\( \\(T^2\\propto r^3\\) \\) Elliptical Orbits : In elliptical orbits, the object moves closer and farther from the central body throughout its orbit. The distance varies, and thus the orbital speed also changes. The central body is located at one of the two foci of the ellipse, and the object\u2019s distance from the focus is not constant. Despite the varying distance, the orbital period is still determined by the semi-major axis ( \\(a\\) ), not by the instantaneous distance of the orbiting body. This means that the orbital period remains the same even though the object\u2019s speed changes throughout its elliptical orbit. The orbit is longer when the object is farther from the central body (at aphelion) and shorter when it\u2019s closer (at perihelion).","title":"2. Difference Between Circular and Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-orbital-speed-in-elliptical-orbits","text":"Unlike in circular orbits where the object\u2019s speed is constant, orbital speed in elliptical orbits varies depending on the object\u2019s distance from the central body. The object moves fastest when it is closest to the focus (at perihelion) and slowest when it is farthest from the focus (at aphelion). This behavior is explained by Kepler\u2019s Second Law , which states: Kepler\u2019s Second Law : A line joining a planet and the Sun sweeps out equal areas during equal intervals of time. This means that when a planet is closer to the Sun, it moves faster to sweep out the same area.","title":"3. Orbital Speed in Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-visualizing-elliptical-orbits","text":"To better understand elliptical orbits, let\u2019s discuss the main characteristics: - Semi-major axis ( \\(a\\) ) : The longest axis of the ellipse, running from one end (aphelion) to the other (perihelion). Eccentricity ( \\(e\\) ) : A measure of how \u201cstretched out\u201d the ellipse is. An eccentricity of 0 corresponds to a perfect circle, while an eccentricity close to 1 indicates a very elongated ellipse. For an elliptical orbit, we can express the relationship between the perihelion ( \\(r_p\\) ) and aphelion ( \\(r_a\\) ) as: \\( \\(r_p=a(1-e)\\) \\) \\( \\(r_a=a(1+e)\\) \\) where \\(e\\) is the eccentricity of the ellipse.","title":"4. Visualizing Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-orbital-period-and-elliptical-orbits","text":"In elliptical orbits, even though the distance from the central body varies, the orbital period still depends only on the semi-major axis ( \\(a\\) ). This is the key takeaway from Kepler\u2019s Third Law for elliptical orbits: the semi-major axis is the defining parameter for the orbital period, just as the orbital radius determines the period in a circular orbit.","title":"5. Orbital Period and Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Circular Orbits : The orbital period depends directly on the orbital radius, and the relationship is simple: \\(T^2\\propto r^3\\) . Elliptical Orbits : The orbital period depends on the semi-major axis ( \\(a\\) ) of the ellipse, and the relationship remains: \\(T^2\\propto a^3\\) . Despite the varying distance, the period is determined by the semi-major axis and remains the same for any elliptical orbit with the same semi-major axis.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#differences-between-circular-and-elliptical-orbits","text":"Characteristic Circular Orbits Elliptical Orbits Shape Perfect circle Ellipse (stretched circle) Orbital Radius Constant Varies (closest at perihelion, farthest at aphelion) Orbital Speed Constant Varies (fastest at perihelion, slowest at aphelion) Orbit Period Depends on radius Depends on semi-major axis (same as for circular orbits with same semi-major axis) Kepler's Third Law applies to both, but the shape and speed variation in elliptical orbits make them more complex, requiring a more thorough understanding of orbital mechanics. However, the fundamental relationship that \\(T^2\\propto a^3\\) holds true for both circular and elliptical orbits.","title":"Differences Between Circular and Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#pythonplot","text":"import numpy as np import matplotlib.pyplot as plt # Orbital data: Semi-major axis (r) in AU, Orbital period (T) in Earth years solar_system_data = { \"Mercury\": {\"r\": 0.39, \"T\": 0.24}, \"Venus\": {\"r\": 0.72, \"T\": 0.62}, \"Earth\": {\"r\": 1.00, \"T\": 1.00}, \"Mars\": {\"r\": 1.52, \"T\": 1.88}, \"Jupiter\": {\"r\": 5.20, \"T\": 11.86}, \"Saturn\": {\"r\": 9.58, \"T\": 29.46}, \"Uranus\": {\"r\": 19.18, \"T\": 84.01}, \"Neptune\": {\"r\": 30.07, \"T\": 164.8} } # Prepare data r_cubed = [] T_squared = [] planet_names = [] for planet, values in solar_system_data.items(): r = values[\"r\"] T = values[\"T\"] r_cubed.append(r**3) T_squared.append(T**2) planet_names.append(planet) # Sorting data by r_cubed for consistent plotting sorted_data = sorted(zip(r_cubed, T_squared, planet_names)) r_cubed, T_squared, planet_names = zip(*sorted_data) # Plotting with log-log scale plt.figure(figsize=(10, 7)) plt.plot(r_cubed, T_squared, '-o', color='royalblue', linewidth=2, markersize=8) plt.xscale('log') plt.yscale('log') # Annotate for i in range(len(planet_names)): plt.annotate(planet_names[i], (r_cubed[i], T_squared[i]), textcoords=\"offset points\", xytext=(6, 4), fontsize=10, weight='bold') # Axis labels and title plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ (Log-Log Scale)\", fontsize=14, weight='bold') plt.xlabel(\"$r^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (years\u00b2)\", fontsize=12) plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.tight_layout() plt.show() Colab","title":"Python/Plot"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 1. Theoretical Foundations \ud83c\udf0c Cosmic Velocities: Overview Cosmic velocities define the thresholds required for an object to achieve various kinds of motion in a gravitational field, ranging from stable orbit to escaping an entire planetary system. There are three major types: \ud83d\ude80 First Cosmic Velocity : Orbital Velocity Definition : The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body without propulsion. Physical Meaning : Balances centripetal force and gravitational force . Object \"falls around\" the planet, never reaching the surface. Derivation : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\\\ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{R}} \\] Where: - \\(G\\) = Gravitational constant \\(\\approx 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) - \\(M\\) = Mass of the celestial body - \\(R\\) = Radius from the center of the body \ud83e\ude90 Second Cosmic Velocity : Escape Velocity Definition : The minimum velocity needed to escape the gravitational field of a celestial body without further propulsion. Physical Meaning : Reaches a point at infinity with zero kinetic energy remaining. Not an orbit \u2014 a one-way departure from the gravitational pull. Derivation : From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] \ud83d\udd0e Note: Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity. \ud83c\udf1e Third Cosmic Velocity : Solar System Escape Velocity Definition : The minimum velocity required to escape the Sun\u2019s gravitational field starting from a planet\u2019s surface. Physical Meaning : Combines: Escape velocity from the planet. Additional velocity to escape the Sun\u2019s pull from the planet\u2019s orbit. Approximate Formula : \\[ v_{\\text{total}}^2 = v_{\\text{planet-escape}}^2 + v_{\\text{sun-orbit}}^2 \\] Where: - \\(v_{\\text{planet-escape}} = \\sqrt{\\frac{2GM_p}{R_p}}\\) - \\(v_{\\text{sun-orbit}} = \\sqrt{\\frac{2GM_s}{r}}\\) - \\(M_p\\) : Mass of the planet - \\(R_p\\) : Radius of the planet - \\(M_s\\) : Mass of the Sun - \\(r\\) : Distance from the planet to the Sun \ud83d\udd2c Comparison Summary Velocity Type Formula Meaning First Cosmic \\(v = \\sqrt{\\frac{GM}{R}}\\) Stable low orbit Second Cosmic \\(v = \\sqrt{\\frac{2GM}{R}}\\) Escape from planet's gravity Third Cosmic Combination of escape + solar Escape from both planet and solar gravitational pull 2. Mathematical Derivations In this section, we derive the formulas for the first , second , and third cosmic velocities based on Newtonian mechanics and energy conservation principles. \ud83d\ude80 First Cosmic Velocity (Orbital Velocity) Goal : Find the velocity needed for an object to maintain a stable circular orbit around a celestial body. Key Idea : Set the gravitational force equal to the centripetal force . \\[ F_{\\text{gravity}}=F_{\\text{centripetal}} \\\\ \\frac{GMm}{R^2}=\\frac{mv^2}{R} \\] Canceling \\(m\\) and simplifying: \\[ v=\\sqrt{\\frac{GM}{R}} \\] Where: - \\(G\\) : Gravitational constant - \\(M\\) : Mass of the planet - \\(R\\) : Distance from the center of the planet \u2705 This is the minimum velocity needed to stay in low circular orbit . \ud83e\ude90 Second Cosmic Velocity (Escape Velocity) Goal : Find the minimum velocity required to completely escape a celestial body's gravity. Key Idea : Use conservation of mechanical energy : Initial total energy = final total energy at infinity (zero) \\[ E_{\\text{initial}}=\\frac{1}{2}mv^2-\\frac{GMm}{R} \\\\ E_{\\text{final}}=0 \\] Solving: \\[ \\frac{1}{2}mv^2-\\frac{GMm}{R}=0 \\\\ v=\\sqrt{\\frac{2GM}{R}} \\] Where: - Same variables as above \ud83d\udd0e Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity. \ud83c\udf1e Third Cosmic Velocity (Interstellar Escape) Goal : Escape the entire solar system starting from the surface of a planet. Key Idea : Combine: Escape from the planet Escape from the Sun\u2019s gravitational field at the planet\u2019s orbital distance Step 1: Escape velocity from the planet : \\[ v_1=\\sqrt{\\frac{2GM_p}{R_p}} \\] Step 2: Escape velocity from the Sun at the planet's orbit : \\[ v_2=\\sqrt{\\frac{2GM_s}{r}} \\] Combined Third Cosmic Velocity (approximation by energy summation): \\[ v_{\\text{total}}=\\sqrt{v_1^2+v_2^2} \\] Where: - \\(M_p\\) : Mass of the planet - \\(R_p\\) : Radius of the planet - \\(M_s\\) : Mass of the Sun - \\(r\\) : Distance of the planet from the Sun \u2600\ufe0f This is the speed required to leave the solar system starting from the planet's surface. \ud83d\udcd8 Summary of Results First Cosmic Velocity : $$ v=\\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity : $$ v=\\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity : $$ v=\\sqrt{\\frac{2GM_p}{R_p}+\\frac{2GM_s}{r}} $$ > These expressions form the theoretical basis for space travel and trajectory planning. 3. Simulations and Calculations We now implement a Python script to compute the first , second , and third cosmic velocities for three selected celestial bodies: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe0 Jupiter We assume Newtonian mechanics and use known astronomical data to evaluate: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) \\(v_3 = \\sqrt{v_1^2 + \\frac{2GM_s}{r}}\\) Where: - \\(G\\) = Gravitational constant - \\(M\\) = Mass of planet - \\(R\\) = Radius of planet - \\(M_s\\) = Mass of the Sun - \\(r\\) = Distance from planet to Sun \ud83e\uddee Python Simulation import numpy as np import pandas as pd # Constants G = 6.67430e-11 # m^3/kg/s^2 M_sun = 1.989e30 # kg # Planetary data: Mass (kg), Radius (m), Orbital radius from Sun (m) planets = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6, 'orbital_radius': 1.496e11 }, 'Mars': { 'mass': 6.417e23, 'radius': 3.3895e6, 'orbital_radius': 2.279e11 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7, 'orbital_radius': 7.785e11 } } # Result storage results = [] for name, data in planets.items(): M = data['mass'] R = data['radius'] r = data['orbital_radius'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + 2 * G * M_sun / r) results.append({ 'Planet': name, 'v1 (Orbital) [km/s]': v1 / 1000, 'v2 (Escape) [km/s]': v2 / 1000, 'v3 (Solar Escape) [km/s]': v3 / 1000 }) df = pd.DataFrame(results) print(df.to_string(index=False)) \ud83d\udcca Tabulated Results The table will look like this (values may vary slightly based on precision): Planet v\u2081 (Orbital) [km/s] v\u2082 (Escape) [km/s] v\u2083 (Solar Escape) [km/s] Earth ~7.91 ~11.18 ~42.1 Mars ~3.56 ~5.03 ~34.1 Jupiter ~42.1 ~59.5 ~87.3 \ud83d\udccc Notes These computations assume: Spherical symmetry No atmospheric drag Instantaneous velocity achieved (no thrust phase) \\(v_3\\) is approximate and assumes escape velocity from Sun calculated at the orbital distance of the planet. 4. Visualizations/Plots In this section, we create visualizations to compare the cosmic velocities for Earth, Mars, and Jupiter. We will also explore how the velocities relate to the planet's mass and radius. \ud83d\udcca Bar Chart: Cosmic Velocities for Earth, Mars, and Jupiter We will plot the first , second , and third cosmic velocities for each planet using bar charts for easy comparison. import matplotlib.pyplot as plt # Extracting data for plotting planets_names = ['Earth', 'Mars', 'Jupiter'] v1_values = [row['v1 (Orbital) [km/s]'] for _, row in df.iterrows()] v2_values = [row['v2 (Escape) [km/s]'] for _, row in df.iterrows()] v3_values = [row['v3 (Solar Escape) [km/s]'] for _, row in df.iterrows()] # Bar chart fig, ax = plt.subplots(figsize=(10, 6)) width = 0.25 # Bar width x = np.arange(len(planets_names)) # Create bars for each velocity type ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity') # Formatting ax.set_xlabel('Planets') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(planets_names) ax.legend() plt.tight_layout() plt.show() \ud83c\udf0d Velocity vs. Planet Mass and Radius We will create two plots to investigate how the cosmic velocities vary with the planet's mass and radius . 1. Velocity vs. Planet Mass 2. Velocity vs. Planet Radius \ud83c\udf10 Optional: 3D or Animation-Based Visuals for Conceptual Understanding For deeper understanding, we can visualize the velocities in 3D space or through animations . 1. 3D Plot of Cosmic Velocities 2. Animation of Planetary Escape \ud83d\udcc8 Final Thoughts - The bar charts and line plots offer a comparative view of cosmic velocities across different planets. 5. Application & Discussion \ud83d\ude80 1. Importance of Each Cosmic Velocity in Real-World Space Missions The concept of cosmic velocities plays a crucial role in modern space exploration. Understanding these velocities is essential for designing spacecraft and planning interplanetary or interstellar missions. Here we explore the significance of each cosmic velocity: 1.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed required for an object to remain in a stable orbit around a planet or star. Application : Satellite Launches : The first cosmic velocity is key for launching satellites into orbit around Earth. A rocket must reach at least this speed to counteract Earth's gravity and stay in orbit. Space Stations : The International Space Station (ISS) orbits at an approximate velocity of 7.66 km/s, which is just slightly above Earth's first cosmic velocity. Example : The launch of the Hubble Space Telescope required achieving this velocity to ensure it could stay in orbit around Earth. 1.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence. This is the speed needed for a spacecraft to break free from Earth\u2019s gravity without further propulsion. Application : Escape from Earth's Gravity : Spacecraft like the Apollo missions or the Mars rovers use this velocity to leave Earth\u2019s atmosphere and escape into interplanetary space. Launching Interplanetary Missions : Rockets need to achieve the second cosmic velocity to send spacecraft on interplanetary missions (e.g., to Mars or Jupiter). Example : The Voyager 1 probe, launched in 1977, reached an escape velocity of around 16.5 km/s, allowing it to break free from Earth\u2019s gravitational influence and begin its journey to interstellar space. 1.3 Third Cosmic Velocity (Solar System Escape Velocity) The third cosmic velocity is the velocity needed to escape not just a planet, but the entire solar system , including escaping the Sun\u2019s gravity. Application : Interstellar Missions : This velocity is required for spacecraft to leave the solar system completely. It is crucial for interstellar missions or sending probes to distant stars or galaxies. Escape from Solar System : Missions aiming to travel beyond the influence of the Sun\u2019s gravity need to achieve this velocity. Example : The Voyager 1 spacecraft achieved this velocity after escaping Earth\u2019s gravity, enabling it to travel toward the interstellar medium . Currently, it is the farthest human-made object from Earth. \ud83c\udf0c 2. Relating Cosmic Velocities to Historical and Planned Space Missions 2.1 Voyager Missions (Voyager 1 & 2) Voyager 1 , launched in 1977, and Voyager 2 , launched in 1977 as well, are key examples of space probes that have used the second and third cosmic velocities to escape Earth\u2019s gravity and the Sun's gravitational pull. Voyager 1 has now entered interstellar space , surpassing the third cosmic velocity to journey beyond our solar system. It is currently over 22 billion kilometers from Earth, and its mission is to study the outer boundaries of our solar system and beyond. 2.2 Artemis Program NASA\u2019s Artemis program , planned for the coming years, aims to send humans back to the Moon and eventually to Mars. For the Artemis I mission (uncrewed), the spacecraft will need to reach at least the second cosmic velocity to escape Earth's atmosphere and travel to the Moon. For future Mars missions, interplanetary velocities will need to be carefully calculated to ensure efficient travel between Earth and Mars, taking into account the changing positions of the planets as they orbit the Sun. 2.3 Mars Rover Missions NASA's Mars rovers , such as Curiosity and Perseverance , need to overcome Earth's gravity (second cosmic velocity) to reach Mars, and then use orbital velocities to safely enter Mars\u2019 atmosphere for landing. Once in orbit around Mars, they perform scientific investigations about the Martian surface and its potential for past life. \ud83c\udf20 3. Conclusion The understanding and application of the first , second , and third cosmic velocities are fundamental for planning space missions, from launching satellites into Earth orbit to sending probes into interstellar space. These velocities help scientists and engineers design spacecraft that can successfully complete their missions and overcome the gravitational challenges posed by celestial bodies. Space exploration will continue to rely on these principles to push the boundaries of our solar system and beyond, and understanding them is key to missions like Voyager , Artemis , and future interstellar travel.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundations","text":"","title":"1. Theoretical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-overview","text":"Cosmic velocities define the thresholds required for an object to achieve various kinds of motion in a gravitational field, ranging from stable orbit to escaping an entire planetary system. There are three major types:","title":"\ud83c\udf0c Cosmic Velocities: Overview"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum horizontal velocity needed for an object to enter a stable circular orbit just above the surface of a celestial body without propulsion. Physical Meaning : Balances centripetal force and gravitational force . Object \"falls around\" the planet, never reaching the surface. Derivation : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\\\ \\frac{GMm}{R^2} = \\frac{mv^2}{R} \\] Solving for velocity \\(v\\) : \\[ v = \\sqrt{\\frac{GM}{R}} \\] Where: - \\(G\\) = Gravitational constant \\(\\approx 6.674 \\times 10^{-11}\\ \\text{Nm}^2/\\text{kg}^2\\) - \\(M\\) = Mass of the celestial body - \\(R\\) = Radius from the center of the body","title":"\ud83d\ude80 First Cosmic Velocity: Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Definition : The minimum velocity needed to escape the gravitational field of a celestial body without further propulsion. Physical Meaning : Reaches a point at infinity with zero kinetic energy remaining. Not an orbit \u2014 a one-way departure from the gravitational pull. Derivation : From conservation of mechanical energy: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2GM}{R}} \\] \ud83d\udd0e Note: Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity.","title":"\ud83e\ude90 Second Cosmic Velocity: Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape-velocity","text":"Definition : The minimum velocity required to escape the Sun\u2019s gravitational field starting from a planet\u2019s surface. Physical Meaning : Combines: Escape velocity from the planet. Additional velocity to escape the Sun\u2019s pull from the planet\u2019s orbit. Approximate Formula : \\[ v_{\\text{total}}^2 = v_{\\text{planet-escape}}^2 + v_{\\text{sun-orbit}}^2 \\] Where: - \\(v_{\\text{planet-escape}} = \\sqrt{\\frac{2GM_p}{R_p}}\\) - \\(v_{\\text{sun-orbit}} = \\sqrt{\\frac{2GM_s}{r}}\\) - \\(M_p\\) : Mass of the planet - \\(R_p\\) : Radius of the planet - \\(M_s\\) : Mass of the Sun - \\(r\\) : Distance from the planet to the Sun","title":"\ud83c\udf1e Third Cosmic Velocity: Solar System Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#comparison-summary","text":"Velocity Type Formula Meaning First Cosmic \\(v = \\sqrt{\\frac{GM}{R}}\\) Stable low orbit Second Cosmic \\(v = \\sqrt{\\frac{2GM}{R}}\\) Escape from planet's gravity Third Cosmic Combination of escape + solar Escape from both planet and solar gravitational pull","title":"\ud83d\udd2c Comparison Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"In this section, we derive the formulas for the first , second , and third cosmic velocities based on Newtonian mechanics and energy conservation principles.","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity_1","text":"Goal : Find the velocity needed for an object to maintain a stable circular orbit around a celestial body. Key Idea : Set the gravitational force equal to the centripetal force . \\[ F_{\\text{gravity}}=F_{\\text{centripetal}} \\\\ \\frac{GMm}{R^2}=\\frac{mv^2}{R} \\] Canceling \\(m\\) and simplifying: \\[ v=\\sqrt{\\frac{GM}{R}} \\] Where: - \\(G\\) : Gravitational constant - \\(M\\) : Mass of the planet - \\(R\\) : Distance from the center of the planet \u2705 This is the minimum velocity needed to stay in low circular orbit .","title":"\ud83d\ude80 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity_1","text":"Goal : Find the minimum velocity required to completely escape a celestial body's gravity. Key Idea : Use conservation of mechanical energy : Initial total energy = final total energy at infinity (zero) \\[ E_{\\text{initial}}=\\frac{1}{2}mv^2-\\frac{GMm}{R} \\\\ E_{\\text{final}}=0 \\] Solving: \\[ \\frac{1}{2}mv^2-\\frac{GMm}{R}=0 \\\\ v=\\sqrt{\\frac{2GM}{R}} \\] Where: - Same variables as above \ud83d\udd0e Escape velocity is \\(\\sqrt{2}\\) times the first cosmic velocity.","title":"\ud83e\ude90 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"Goal : Escape the entire solar system starting from the surface of a planet. Key Idea : Combine: Escape from the planet Escape from the Sun\u2019s gravitational field at the planet\u2019s orbital distance Step 1: Escape velocity from the planet : \\[ v_1=\\sqrt{\\frac{2GM_p}{R_p}} \\] Step 2: Escape velocity from the Sun at the planet's orbit : \\[ v_2=\\sqrt{\\frac{2GM_s}{r}} \\] Combined Third Cosmic Velocity (approximation by energy summation): \\[ v_{\\text{total}}=\\sqrt{v_1^2+v_2^2} \\] Where: - \\(M_p\\) : Mass of the planet - \\(R_p\\) : Radius of the planet - \\(M_s\\) : Mass of the Sun - \\(r\\) : Distance of the planet from the Sun \u2600\ufe0f This is the speed required to leave the solar system starting from the planet's surface.","title":"\ud83c\udf1e Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary-of-results","text":"First Cosmic Velocity : $$ v=\\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity : $$ v=\\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity : $$ v=\\sqrt{\\frac{2GM_p}{R_p}+\\frac{2GM_s}{r}} $$","title":"\ud83d\udcd8 Summary of Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#these-expressions-form-the-theoretical-basis-for-space-travel-and-trajectory-planning","text":"","title":"&gt; These expressions form the theoretical basis for space travel and trajectory planning."},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-simulations-and-calculations","text":"We now implement a Python script to compute the first , second , and third cosmic velocities for three selected celestial bodies: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe0 Jupiter We assume Newtonian mechanics and use known astronomical data to evaluate: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) \\(v_3 = \\sqrt{v_1^2 + \\frac{2GM_s}{r}}\\) Where: - \\(G\\) = Gravitational constant - \\(M\\) = Mass of planet - \\(R\\) = Radius of planet - \\(M_s\\) = Mass of the Sun - \\(r\\) = Distance from planet to Sun","title":"3. Simulations and Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"import numpy as np import pandas as pd # Constants G = 6.67430e-11 # m^3/kg/s^2 M_sun = 1.989e30 # kg # Planetary data: Mass (kg), Radius (m), Orbital radius from Sun (m) planets = { 'Earth': { 'mass': 5.972e24, 'radius': 6.371e6, 'orbital_radius': 1.496e11 }, 'Mars': { 'mass': 6.417e23, 'radius': 3.3895e6, 'orbital_radius': 2.279e11 }, 'Jupiter': { 'mass': 1.898e27, 'radius': 6.9911e7, 'orbital_radius': 7.785e11 } } # Result storage results = [] for name, data in planets.items(): M = data['mass'] R = data['radius'] r = data['orbital_radius'] v1 = np.sqrt(G * M / R) v2 = np.sqrt(2 * G * M / R) v3 = np.sqrt(v2**2 + 2 * G * M_sun / r) results.append({ 'Planet': name, 'v1 (Orbital) [km/s]': v1 / 1000, 'v2 (Escape) [km/s]': v2 / 1000, 'v3 (Solar Escape) [km/s]': v3 / 1000 }) df = pd.DataFrame(results) print(df.to_string(index=False))","title":"\ud83e\uddee Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#tabulated-results","text":"The table will look like this (values may vary slightly based on precision): Planet v\u2081 (Orbital) [km/s] v\u2082 (Escape) [km/s] v\u2083 (Solar Escape) [km/s] Earth ~7.91 ~11.18 ~42.1 Mars ~3.56 ~5.03 ~34.1 Jupiter ~42.1 ~59.5 ~87.3","title":"\ud83d\udcca Tabulated Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#notes","text":"These computations assume: Spherical symmetry No atmospheric drag Instantaneous velocity achieved (no thrust phase) \\(v_3\\) is approximate and assumes escape velocity from Sun calculated at the orbital distance of the planet.","title":"\ud83d\udccc Notes"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-visualizationsplots","text":"In this section, we create visualizations to compare the cosmic velocities for Earth, Mars, and Jupiter. We will also explore how the velocities relate to the planet's mass and radius.","title":"4. Visualizations/Plots"},{"location":"1%20Physics/2%20Gravity/Problem_2/#bar-chart-cosmic-velocities-for-earth-mars-and-jupiter","text":"We will plot the first , second , and third cosmic velocities for each planet using bar charts for easy comparison. import matplotlib.pyplot as plt # Extracting data for plotting planets_names = ['Earth', 'Mars', 'Jupiter'] v1_values = [row['v1 (Orbital) [km/s]'] for _, row in df.iterrows()] v2_values = [row['v2 (Escape) [km/s]'] for _, row in df.iterrows()] v3_values = [row['v3 (Solar Escape) [km/s]'] for _, row in df.iterrows()] # Bar chart fig, ax = plt.subplots(figsize=(10, 6)) width = 0.25 # Bar width x = np.arange(len(planets_names)) # Create bars for each velocity type ax.bar(x - width, v1_values, width, label='First Cosmic Velocity') ax.bar(x, v2_values, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_values, width, label='Third Cosmic Velocity') # Formatting ax.set_xlabel('Planets') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, and Jupiter') ax.set_xticks(x) ax.set_xticklabels(planets_names) ax.legend() plt.tight_layout() plt.show()","title":"\ud83d\udcca Bar Chart: Cosmic Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#velocity-vs-planet-mass-and-radius","text":"We will create two plots to investigate how the cosmic velocities vary with the planet's mass and radius .","title":"\ud83c\udf0d Velocity vs. Planet Mass and Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-velocity-vs-planet-mass","text":"","title":"1. Velocity vs. Planet Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-velocity-vs-planet-radius","text":"","title":"2. Velocity vs. Planet Radius"},{"location":"1%20Physics/2%20Gravity/Problem_2/#optional-3d-or-animation-based-visuals-for-conceptual-understanding","text":"For deeper understanding, we can visualize the velocities in 3D space or through animations .","title":"\ud83c\udf10 Optional: 3D or Animation-Based Visuals for Conceptual Understanding"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-3d-plot-of-cosmic-velocities","text":"","title":"1. 3D Plot of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-animation-of-planetary-escape","text":"","title":"2. Animation of Planetary Escape"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#final-thoughts","text":"","title":"\ud83d\udcc8 Final Thoughts"},{"location":"1%20Physics/2%20Gravity/Problem_2/#-the-bar-charts-and-line-plots-offer-a-comparative-view-of-cosmic-velocities-across-different-planets","text":"","title":"- The bar charts and line plots offer a comparative view of cosmic velocities across different planets."},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-application-discussion","text":"","title":"5. Application &amp; Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-importance-of-each-cosmic-velocity-in-real-world-space-missions","text":"The concept of cosmic velocities plays a crucial role in modern space exploration. Understanding these velocities is essential for designing spacecraft and planning interplanetary or interstellar missions. Here we explore the significance of each cosmic velocity:","title":"\ud83d\ude80 1. Importance of Each Cosmic Velocity in Real-World Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed required for an object to remain in a stable orbit around a planet or star. Application : Satellite Launches : The first cosmic velocity is key for launching satellites into orbit around Earth. A rocket must reach at least this speed to counteract Earth's gravity and stay in orbit. Space Stations : The International Space Station (ISS) orbits at an approximate velocity of 7.66 km/s, which is just slightly above Earth's first cosmic velocity. Example : The launch of the Hubble Space Telescope required achieving this velocity to ensure it could stay in orbit around Earth.","title":"1.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum velocity required to escape a celestial body's gravitational influence. This is the speed needed for a spacecraft to break free from Earth\u2019s gravity without further propulsion. Application : Escape from Earth's Gravity : Spacecraft like the Apollo missions or the Mars rovers use this velocity to leave Earth\u2019s atmosphere and escape into interplanetary space. Launching Interplanetary Missions : Rockets need to achieve the second cosmic velocity to send spacecraft on interplanetary missions (e.g., to Mars or Jupiter). Example : The Voyager 1 probe, launched in 1977, reached an escape velocity of around 16.5 km/s, allowing it to break free from Earth\u2019s gravitational influence and begin its journey to interstellar space.","title":"1.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity-solar-system-escape-velocity","text":"The third cosmic velocity is the velocity needed to escape not just a planet, but the entire solar system , including escaping the Sun\u2019s gravity. Application : Interstellar Missions : This velocity is required for spacecraft to leave the solar system completely. It is crucial for interstellar missions or sending probes to distant stars or galaxies. Escape from Solar System : Missions aiming to travel beyond the influence of the Sun\u2019s gravity need to achieve this velocity. Example : The Voyager 1 spacecraft achieved this velocity after escaping Earth\u2019s gravity, enabling it to travel toward the interstellar medium . Currently, it is the farthest human-made object from Earth.","title":"1.3 Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-relating-cosmic-velocities-to-historical-and-planned-space-missions","text":"","title":"\ud83c\udf0c 2. Relating Cosmic Velocities to Historical and Planned Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-voyager-missions-voyager-1-2","text":"Voyager 1 , launched in 1977, and Voyager 2 , launched in 1977 as well, are key examples of space probes that have used the second and third cosmic velocities to escape Earth\u2019s gravity and the Sun's gravitational pull. Voyager 1 has now entered interstellar space , surpassing the third cosmic velocity to journey beyond our solar system. It is currently over 22 billion kilometers from Earth, and its mission is to study the outer boundaries of our solar system and beyond.","title":"2.1 Voyager Missions (Voyager 1 &amp; 2)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-artemis-program","text":"NASA\u2019s Artemis program , planned for the coming years, aims to send humans back to the Moon and eventually to Mars. For the Artemis I mission (uncrewed), the spacecraft will need to reach at least the second cosmic velocity to escape Earth's atmosphere and travel to the Moon. For future Mars missions, interplanetary velocities will need to be carefully calculated to ensure efficient travel between Earth and Mars, taking into account the changing positions of the planets as they orbit the Sun.","title":"2.2 Artemis Program"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-mars-rover-missions","text":"NASA's Mars rovers , such as Curiosity and Perseverance , need to overcome Earth's gravity (second cosmic velocity) to reach Mars, and then use orbital velocities to safely enter Mars\u2019 atmosphere for landing. Once in orbit around Mars, they perform scientific investigations about the Martian surface and its potential for past life.","title":"2.3 Mars Rover Missions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-conclusion","text":"The understanding and application of the first , second , and third cosmic velocities are fundamental for planning space missions, from launching satellites into Earth orbit to sending probes into interstellar space. These velocities help scientists and engineers design spacecraft that can successfully complete their missions and overcome the gravitational challenges posed by celestial bodies. Space exploration will continue to rely on these principles to push the boundaries of our solar system and beyond, and understanding them is key to missions like Voyager , Artemis , and future interstellar travel.","title":"\ud83c\udf20 3. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Theoretical Foundation Newton\u2019s Law of Gravitation Newton's Law of Universal Gravitation states that any two masses in the universe attract each other with a force given by: \\[F=G\\frac{m_1m_2}{r^2}\\] where: - \\(F\\) is the gravitational force, \\(G\\) is the gravitational constant ( \\(6.674\\times10^{-11}\\) m\u00b2/kg\u00b2) \\(m_1,m_2\\) are the masses of the two objects, \\(r\\) is the distance between the objects. For a payload near Earth, the force simplifies to: \\[F=G\\frac{M_Em}{r^2}\\] where \\(M_E\\) is Earth's mass and \\(r\\) is the distance from Earth's center. The acceleration due to gravity is: \\[g=\\frac{GM_E}{r^2}\\] which varies with altitude. Kepler\u2019s Laws of Planetary Motion First Law (Elliptical Orbits) : Planets move in ellipses with the Sun at one focus. Similarly, a payload follows an elliptical, parabolic, or hyperbolic path based on its initial velocity. Second Law (Equal Areas in Equal Time) : The line joining a planet and the Sun sweeps equal areas in equal time. This implies that an object moves faster when closer to Earth. Third Law (Orbital Period Relation) : The square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis: \\[T^2\\propto a^3\\] This helps in predicting orbital parameters. Classification of Possible Trajectories The motion of a payload depends on its total energy: \\[E=\\frac{1}{2}mv^2-\\frac{GM_Em}{r}\\] If \\(E<0\\) \u2192 Elliptical orbit (Bound motion) If \\(E=0\\) \u2192 Parabolic trajectory (Escape condition) If \\(E>0\\) \u2192 Hyperbolic trajectory (Unbound motion) The escape velocity is given by: \\[v_{esc}=\\sqrt{\\frac{2GM_E}{r}}\\] Conditions for Orbital Insertion, Reentry, or Escape Orbital Insertion : Requires achieving a velocity that results in a stable bound orbit. For a circular orbit at altitude \\(h\\) : \\[v_{orbit}=\\sqrt{\\frac{GM_E}{R_E+h}}\\] Reentry Conditions : A payload must reduce velocity to enter the atmosphere. Atmospheric drag plays a key role in slowing it down. Escape Trajectories : If velocity exceeds escape velocity, the payload follows a hyperbolic trajectory away from Earth. This theoretical background lays the foundation for numerical simulations of payload trajectories. Mathematical Formulation Equations of Motion for a Payload under Earth's Gravity The motion of a payload is governed by Newton\u2019s Second Law: \\[F=ma\\] Since the only force acting is gravity: \\[m\\frac{d^2\\mathbf{r}}{dt^2}=-G\\frac{M_Em}{r^2}\\hat{r}\\] Simplifying: \\[\\frac{d^2\\mathbf{r}}{dt^2}=-G\\frac{M_E}{r^2}\\hat{r}\\] In Cartesian coordinates: \\[\\frac{d^2x}{dt^2}=-G\\frac{M_E}{r^3}x\\] \\[\\frac{d^2y}{dt^2}=-G\\frac{M_E}{r^3}y\\] \\[\\frac{d^2z}{dt^2}=-G\\frac{M_E}{r^3}z\\] where \\(r=\\sqrt{x^2+y^2+z^2}\\) . Consideration of Initial Velocity, Altitude, and Direction Initial position: \\[\\mathbf{r_0}=(x_0,y_0,z_0)\\] Initial velocity: \\[\\mathbf{v_0}=(v_{x0},v_{y0},v_{z0})\\] The trajectory depends on: Magnitude and direction of \\(\\mathbf{v_0}\\) . The altitude ( \\(h\\) ) from the Earth's surface: \\[r_0=R_E+h\\] Criteria for Different Trajectories The total specific energy determines the trajectory: \\[E=\\frac{1}{2}v^2-\\frac{GM_E}{r}\\] If \\(E<0\\) : Elliptical orbit (Bound motion) If \\(E=0\\) : Parabolic trajectory (Escape condition) If \\(E>0\\) : Hyperbolic trajectory (Unbound motion) Escape velocity condition: \\[v_0\\geq\\sqrt{\\frac{2GM_E}{r_0}}\\] ensures that the payload escapes Earth's gravitational influence. This mathematical formulation establishes the foundation for numerical simulations of payload motion. Numerical Simulation Implement a Python Script to Solve the Equations of Motion We solve the equations of motion numerically using an appropriate method such as the Runge-Kutta method. The equations of motion are: \\[ m \\frac{d^2 \\mathbf{r}}{dt^2} = - G \\frac{M_E m}{r^2} \\hat{r} \\] This simplifies to: \\[ \\frac{d^2 \\mathbf{r}}{dt^2} = - G \\frac{M_E}{r^2} \\hat{r} \\] To implement this, we break it down into first-order differential equations by defining velocity as: \\[ \\mathbf{v} = \\frac{d \\mathbf{r}}{dt} \\] Thus, we can write the system of equations as: \\[ \\frac{d \\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d \\mathbf{v}}{dt} = - G \\frac{M_E}{r^2} \\hat{r} \\] Use Numerical Methods (e.g., Runge-Kutta) for Trajectory Calculations The Runge-Kutta method is an efficient and accurate way to numerically solve these differential equations. The fourth-order Runge-Kutta method (RK4) is commonly used for its balance between complexity and accuracy. Let the system of differential equations be represented as: \\[ \\mathbf{r}' = \\mathbf{v} \\] \\[ \\mathbf{v}' = - G \\frac{M_E}{r^2} \\hat{r} \\] The Runge-Kutta method will numerically integrate these equations step-by-step, providing the trajectory of the payload over time. Account for Different Initial Conditions We consider various initial conditions, such as: Initial position: \\[ \\mathbf{r_0} = (x_0, y_0, z_0) \\] Initial velocity: \\[ \\mathbf{v_0} = (v_{x0}, v_{y0}, v_{z0}) \\] The trajectory depends on the magnitude and direction of the initial velocity and the altitude: \\[ r_0 = R_E + h \\] Python Implementation The following Python code can be used to solve these equations using the Runge-Kutta method: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_E = 5.972e24 # Earth's mass (kg) R_E = 6371000 # Earth's radius (m) # Initial conditions r0 = np.array([R_E + 100000, 0, 0]) # 100 km above Earth's surface v0 = np.array([0, 7800, 0]) # orbital velocity in m/s # Time parameters t_max = 5000 # total simulation time in seconds dt = 1 # time step in seconds # Runge-Kutta integrator def runge_kutta_step(r, v, dt): r_mag = np.linalg.norm(r) if r_mag < R_E: raise ValueError(\"Object has collided with Earth!\") a = -G * M_E * r / r_mag**3 k1v, k1r = dt * a, dt * v r2, v2 = r + 0.5 * k1r, v + 0.5 * k1v a2 = -G * M_E * r2 / np.linalg.norm(r2)**3 k2v, k2r = dt * a2, dt * v2 r3, v3 = r + 0.5 * k2r, v + 0.5 * k2v a3 = -G * M_E * r3 / np.linalg.norm(r3)**3 k3v, k3r = dt * a3, dt * v3 r4, v4 = r + k3r, v + k3v a4 = -G * M_E * r4 / np.linalg.norm(r4)**3 k4v, k4r = dt * a4, dt * v4 v_next = v + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r_next = r + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 return r_next, v_next # Simulation loop r, v = r0, v0 positions = [] for t in np.arange(0, t_max, dt): positions.append(r) try: r, v = runge_kutta_step(r, v, dt) except ValueError as e: print(e) break positions = np.array(positions) # Plotting fig, ax = plt.subplots(figsize=(8, 8)) ax.plot(positions[:, 0], positions[:, 1], label=\"Trajectory\", color='blue') # Draw Earth as a red circle earth = plt.Circle((0, 0), R_E, color='red', label='Earth', alpha=0.6) ax.add_patch(earth) ax.set_title('Trajectory of the Payload') ax.set_xlabel('X position (m)') ax.set_ylabel('Y position (m)') ax.set_aspect('equal') ax.legend() ax.grid(True) plt.show() Visualization & Analysis Generate Plots for Various Payload Trajectories To visualize the payload's motion, we generate several plots that help analyze the behavior of the trajectory. The primary visualizations include: Time evolution of position and velocity. Phase space diagrams. Orbit visualizations. Time Evolution of Position and Velocity We can plot the time evolution of the payload's position and velocity over time to understand how they change as the payload moves under Earth's gravitational influence. Phase Space Diagrams A phase space diagram shows the relationship between position and velocity. For a two-dimensional system, we can plot the position in the x-direction versus the velocity in the x-direction, and similarly for the y and z components. Orbit Visualizations We can visualize the payload's orbit as it moves through space. This plot will show the path in 3D space, displaying the orbital trajectory relative to Earth. Additional Analysis In addition to the plots above, other analyses could include: Energy plots : Tracking the total mechanical energy (kinetic + potential) over time to check for conservation. Orbital insertion analysis : Determining whether the payload is in a bound orbit or has escaped Earth\u2019s gravitational influence. Conclusion These visualizations help to better understand the motion of the payload under the influence of gravity. By examining the time evolution of position and velocity, phase space diagrams, and orbit visualizations, we can gain insights into the nature of the trajectory, whether elliptical, hyperbolic, or parabolic. Visuals Real-World Applications Relevance to Space Missions and Satellite Deployment The study of payload trajectories is essential for various space missions, particularly those involving satellite deployment, payload release, or reentry. The trajectory analysis helps in determining: Orbital Insertion : The process of placing a satellite into orbit requires a precise calculation of the velocity and trajectory, ensuring that the payload reaches the correct altitude and orbital velocity. Satellite Deployment : When deploying satellites from a spacecraft, the release velocity and angle must be carefully chosen to ensure that the satellite remains in orbit or follows the intended path. The velocity required for an object to maintain a stable orbit around Earth is determined by the following equation: $$ v = \\sqrt{\\frac{GM_E}{r}} $$ Where: - \\(G\\) is the gravitational constant, \\(M_E\\) is Earth's mass, \\(r\\) is the orbital radius (distance from Earth's center). The altitude at which the payload is released, and its initial velocity, are critical for the success of satellite deployment. If the velocity is too low, the satellite will fall back to Earth. If the velocity is too high, the satellite may escape Earth's gravity. Reentry Strategies Reentry into Earth's atmosphere requires precise control of the payload's trajectory to ensure it slows down enough to avoid burning up due to friction. The conditions for reentry are influenced by: Orbital Decay : Over time, satellites in low Earth orbit experience atmospheric drag, which causes their orbits to decay, eventually leading to reentry. Reentry Angle : The angle at which a spacecraft reenters the atmosphere affects the amount of heat and stress it experiences. A shallow reentry angle may cause the spacecraft to skip off the atmosphere, while a steep angle may lead to rapid deceleration and heat buildup. The critical speed required to escape Earth's gravity is called the escape velocity , and is given by: \\[ v_{esc} = \\sqrt{\\frac{2GM_E}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, \\(G\\) is the gravitational constant, \\(M_E\\) is Earth's mass, \\(r\\) is the distance from Earth's center. For Earth, the escape velocity at the surface is approximately 11.2 km/s. This is the minimum speed an object must have to escape Earth's gravitational pull without further propulsion. Escape Velocity Calculations The escape velocity is a crucial concept for both sending payloads into space and understanding celestial mechanics. Escape velocity depends on the mass of the planet (or celestial body) and the distance from its center. For Earth, the escape velocity at sea level is approximately: \\[ v_{esc} = \\sqrt{\\frac{2 \\times 6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6371000}} \\approx 11.2 \\, \\text{km/s} \\] This formula is used in space missions for determining the velocity needed to launch spacecraft or payloads that will leave Earth's gravitational influence. Case Studies and Historical Examples Apollo Missions : The Apollo missions to the Moon relied heavily on precise trajectory calculations to ensure the spacecraft reached the correct orbital path to the Moon. The escape velocity was calculated to be sufficient to break free from Earth\u2019s gravitational field, and the reentry velocity was carefully controlled to ensure a safe landing back on Earth. Satellite Deployment : The deployment of the International Space Station (ISS) involved launching multiple payloads into low Earth orbit (LEO) at a specific velocity and altitude. These satellites had to be deployed at the correct time and velocity to match the ISS\u2019s orbit, ensuring their correct insertion into orbit. The precision in calculating the payload's trajectory was critical for both successful orbital insertion and reentry. The correct trajectory also ensured that the deployed satellites would remain operational for their intended missions. Conclusion The concepts of escape velocity, orbital insertion, and trajectory analysis are foundational in space exploration and satellite deployment. Understanding these principles allows for the successful launch, deployment, and reentry of payloads, making them vital for future space missions, including Mars exploration, lunar missions, and the growing field of satellite-based communications and earth observation.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"Newton's Law of Universal Gravitation states that any two masses in the universe attract each other with a force given by: \\[F=G\\frac{m_1m_2}{r^2}\\] where: - \\(F\\) is the gravitational force, \\(G\\) is the gravitational constant ( \\(6.674\\times10^{-11}\\) m\u00b2/kg\u00b2) \\(m_1,m_2\\) are the masses of the two objects, \\(r\\) is the distance between the objects. For a payload near Earth, the force simplifies to: \\[F=G\\frac{M_Em}{r^2}\\] where \\(M_E\\) is Earth's mass and \\(r\\) is the distance from Earth's center. The acceleration due to gravity is: \\[g=\\frac{GM_E}{r^2}\\] which varies with altitude.","title":"Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-laws-of-planetary-motion","text":"First Law (Elliptical Orbits) : Planets move in ellipses with the Sun at one focus. Similarly, a payload follows an elliptical, parabolic, or hyperbolic path based on its initial velocity. Second Law (Equal Areas in Equal Time) : The line joining a planet and the Sun sweeps equal areas in equal time. This implies that an object moves faster when closer to Earth. Third Law (Orbital Period Relation) : The square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis: \\[T^2\\propto a^3\\] This helps in predicting orbital parameters.","title":"Kepler\u2019s Laws of Planetary Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#classification-of-possible-trajectories","text":"The motion of a payload depends on its total energy: \\[E=\\frac{1}{2}mv^2-\\frac{GM_Em}{r}\\] If \\(E<0\\) \u2192 Elliptical orbit (Bound motion) If \\(E=0\\) \u2192 Parabolic trajectory (Escape condition) If \\(E>0\\) \u2192 Hyperbolic trajectory (Unbound motion) The escape velocity is given by: \\[v_{esc}=\\sqrt{\\frac{2GM_E}{r}}\\]","title":"Classification of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conditions-for-orbital-insertion-reentry-or-escape","text":"Orbital Insertion : Requires achieving a velocity that results in a stable bound orbit. For a circular orbit at altitude \\(h\\) : \\[v_{orbit}=\\sqrt{\\frac{GM_E}{R_E+h}}\\] Reentry Conditions : A payload must reduce velocity to enter the atmosphere. Atmospheric drag plays a key role in slowing it down. Escape Trajectories : If velocity exceeds escape velocity, the payload follows a hyperbolic trajectory away from Earth.","title":"Conditions for Orbital Insertion, Reentry, or Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#this-theoretical-background-lays-the-foundation-for-numerical-simulations-of-payload-trajectories","text":"","title":"This theoretical background lays the foundation for numerical simulations of payload trajectories."},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-formulation","text":"","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion-for-a-payload-under-earths-gravity","text":"The motion of a payload is governed by Newton\u2019s Second Law: \\[F=ma\\] Since the only force acting is gravity: \\[m\\frac{d^2\\mathbf{r}}{dt^2}=-G\\frac{M_Em}{r^2}\\hat{r}\\] Simplifying: \\[\\frac{d^2\\mathbf{r}}{dt^2}=-G\\frac{M_E}{r^2}\\hat{r}\\] In Cartesian coordinates: \\[\\frac{d^2x}{dt^2}=-G\\frac{M_E}{r^3}x\\] \\[\\frac{d^2y}{dt^2}=-G\\frac{M_E}{r^3}y\\] \\[\\frac{d^2z}{dt^2}=-G\\frac{M_E}{r^3}z\\] where \\(r=\\sqrt{x^2+y^2+z^2}\\) .","title":"Equations of Motion for a Payload under Earth's Gravity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#consideration-of-initial-velocity-altitude-and-direction","text":"Initial position: \\[\\mathbf{r_0}=(x_0,y_0,z_0)\\] Initial velocity: \\[\\mathbf{v_0}=(v_{x0},v_{y0},v_{z0})\\] The trajectory depends on: Magnitude and direction of \\(\\mathbf{v_0}\\) . The altitude ( \\(h\\) ) from the Earth's surface: \\[r_0=R_E+h\\]","title":"Consideration of Initial Velocity, Altitude, and Direction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#criteria-for-different-trajectories","text":"The total specific energy determines the trajectory: \\[E=\\frac{1}{2}v^2-\\frac{GM_E}{r}\\] If \\(E<0\\) : Elliptical orbit (Bound motion) If \\(E=0\\) : Parabolic trajectory (Escape condition) If \\(E>0\\) : Hyperbolic trajectory (Unbound motion) Escape velocity condition: \\[v_0\\geq\\sqrt{\\frac{2GM_E}{r_0}}\\] ensures that the payload escapes Earth's gravitational influence.","title":"Criteria for Different Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#this-mathematical-formulation-establishes-the-foundation-for-numerical-simulations-of-payload-motion","text":"","title":"This mathematical formulation establishes the foundation for numerical simulations of payload motion."},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#implement-a-python-script-to-solve-the-equations-of-motion","text":"We solve the equations of motion numerically using an appropriate method such as the Runge-Kutta method. The equations of motion are: \\[ m \\frac{d^2 \\mathbf{r}}{dt^2} = - G \\frac{M_E m}{r^2} \\hat{r} \\] This simplifies to: \\[ \\frac{d^2 \\mathbf{r}}{dt^2} = - G \\frac{M_E}{r^2} \\hat{r} \\] To implement this, we break it down into first-order differential equations by defining velocity as: \\[ \\mathbf{v} = \\frac{d \\mathbf{r}}{dt} \\] Thus, we can write the system of equations as: \\[ \\frac{d \\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d \\mathbf{v}}{dt} = - G \\frac{M_E}{r^2} \\hat{r} \\]","title":"Implement a Python Script to Solve the Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#use-numerical-methods-eg-runge-kutta-for-trajectory-calculations","text":"The Runge-Kutta method is an efficient and accurate way to numerically solve these differential equations. The fourth-order Runge-Kutta method (RK4) is commonly used for its balance between complexity and accuracy. Let the system of differential equations be represented as: \\[ \\mathbf{r}' = \\mathbf{v} \\] \\[ \\mathbf{v}' = - G \\frac{M_E}{r^2} \\hat{r} \\] The Runge-Kutta method will numerically integrate these equations step-by-step, providing the trajectory of the payload over time.","title":"Use Numerical Methods (e.g., Runge-Kutta) for Trajectory Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#account-for-different-initial-conditions","text":"We consider various initial conditions, such as: Initial position: \\[ \\mathbf{r_0} = (x_0, y_0, z_0) \\] Initial velocity: \\[ \\mathbf{v_0} = (v_{x0}, v_{y0}, v_{z0}) \\] The trajectory depends on the magnitude and direction of the initial velocity and the altitude: \\[ r_0 = R_E + h \\]","title":"Account for Different Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"The following Python code can be used to solve these equations using the Runge-Kutta method: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_E = 5.972e24 # Earth's mass (kg) R_E = 6371000 # Earth's radius (m) # Initial conditions r0 = np.array([R_E + 100000, 0, 0]) # 100 km above Earth's surface v0 = np.array([0, 7800, 0]) # orbital velocity in m/s # Time parameters t_max = 5000 # total simulation time in seconds dt = 1 # time step in seconds # Runge-Kutta integrator def runge_kutta_step(r, v, dt): r_mag = np.linalg.norm(r) if r_mag < R_E: raise ValueError(\"Object has collided with Earth!\") a = -G * M_E * r / r_mag**3 k1v, k1r = dt * a, dt * v r2, v2 = r + 0.5 * k1r, v + 0.5 * k1v a2 = -G * M_E * r2 / np.linalg.norm(r2)**3 k2v, k2r = dt * a2, dt * v2 r3, v3 = r + 0.5 * k2r, v + 0.5 * k2v a3 = -G * M_E * r3 / np.linalg.norm(r3)**3 k3v, k3r = dt * a3, dt * v3 r4, v4 = r + k3r, v + k3v a4 = -G * M_E * r4 / np.linalg.norm(r4)**3 k4v, k4r = dt * a4, dt * v4 v_next = v + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r_next = r + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 return r_next, v_next # Simulation loop r, v = r0, v0 positions = [] for t in np.arange(0, t_max, dt): positions.append(r) try: r, v = runge_kutta_step(r, v, dt) except ValueError as e: print(e) break positions = np.array(positions) # Plotting fig, ax = plt.subplots(figsize=(8, 8)) ax.plot(positions[:, 0], positions[:, 1], label=\"Trajectory\", color='blue') # Draw Earth as a red circle earth = plt.Circle((0, 0), R_E, color='red', label='Earth', alpha=0.6) ax.add_patch(earth) ax.set_title('Trajectory of the Payload') ax.set_xlabel('X position (m)') ax.set_ylabel('Y position (m)') ax.set_aspect('equal') ax.legend() ax.grid(True) plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization-analysis","text":"","title":"Visualization &amp; Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#generate-plots-for-various-payload-trajectories","text":"To visualize the payload's motion, we generate several plots that help analyze the behavior of the trajectory. The primary visualizations include: Time evolution of position and velocity. Phase space diagrams. Orbit visualizations.","title":"Generate Plots for Various Payload Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-evolution-of-position-and-velocity","text":"We can plot the time evolution of the payload's position and velocity over time to understand how they change as the payload moves under Earth's gravitational influence.","title":"Time Evolution of Position and Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#phase-space-diagrams","text":"A phase space diagram shows the relationship between position and velocity. For a two-dimensional system, we can plot the position in the x-direction versus the velocity in the x-direction, and similarly for the y and z components.","title":"Phase Space Diagrams"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbit-visualizations","text":"We can visualize the payload's orbit as it moves through space. This plot will show the path in 3D space, displaying the orbital trajectory relative to Earth.","title":"Orbit Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#additional-analysis","text":"In addition to the plots above, other analyses could include: Energy plots : Tracking the total mechanical energy (kinetic + potential) over time to check for conservation. Orbital insertion analysis : Determining whether the payload is in a bound orbit or has escaped Earth\u2019s gravitational influence.","title":"Additional Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"These visualizations help to better understand the motion of the payload under the influence of gravity. By examining the time evolution of position and velocity, phase space diagrams, and orbit visualizations, we can gain insights into the nature of the trajectory, whether elliptical, hyperbolic, or parabolic.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visuals","text":"","title":"Visuals"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#_2","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#relevance-to-space-missions-and-satellite-deployment","text":"The study of payload trajectories is essential for various space missions, particularly those involving satellite deployment, payload release, or reentry. The trajectory analysis helps in determining: Orbital Insertion : The process of placing a satellite into orbit requires a precise calculation of the velocity and trajectory, ensuring that the payload reaches the correct altitude and orbital velocity. Satellite Deployment : When deploying satellites from a spacecraft, the release velocity and angle must be carefully chosen to ensure that the satellite remains in orbit or follows the intended path. The velocity required for an object to maintain a stable orbit around Earth is determined by the following equation: $$ v = \\sqrt{\\frac{GM_E}{r}} $$ Where: - \\(G\\) is the gravitational constant, \\(M_E\\) is Earth's mass, \\(r\\) is the orbital radius (distance from Earth's center). The altitude at which the payload is released, and its initial velocity, are critical for the success of satellite deployment. If the velocity is too low, the satellite will fall back to Earth. If the velocity is too high, the satellite may escape Earth's gravity.","title":"Relevance to Space Missions and Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry-strategies","text":"Reentry into Earth's atmosphere requires precise control of the payload's trajectory to ensure it slows down enough to avoid burning up due to friction. The conditions for reentry are influenced by: Orbital Decay : Over time, satellites in low Earth orbit experience atmospheric drag, which causes their orbits to decay, eventually leading to reentry. Reentry Angle : The angle at which a spacecraft reenters the atmosphere affects the amount of heat and stress it experiences. A shallow reentry angle may cause the spacecraft to skip off the atmosphere, while a steep angle may lead to rapid deceleration and heat buildup. The critical speed required to escape Earth's gravity is called the escape velocity , and is given by: \\[ v_{esc} = \\sqrt{\\frac{2GM_E}{r}} \\] Where: - \\(v_{esc}\\) is the escape velocity, \\(G\\) is the gravitational constant, \\(M_E\\) is Earth's mass, \\(r\\) is the distance from Earth's center. For Earth, the escape velocity at the surface is approximately 11.2 km/s. This is the minimum speed an object must have to escape Earth's gravitational pull without further propulsion.","title":"Reentry Strategies"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity-calculations","text":"The escape velocity is a crucial concept for both sending payloads into space and understanding celestial mechanics. Escape velocity depends on the mass of the planet (or celestial body) and the distance from its center. For Earth, the escape velocity at sea level is approximately: \\[ v_{esc} = \\sqrt{\\frac{2 \\times 6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6371000}} \\approx 11.2 \\, \\text{km/s} \\] This formula is used in space missions for determining the velocity needed to launch spacecraft or payloads that will leave Earth's gravitational influence.","title":"Escape Velocity Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#case-studies-and-historical-examples","text":"Apollo Missions : The Apollo missions to the Moon relied heavily on precise trajectory calculations to ensure the spacecraft reached the correct orbital path to the Moon. The escape velocity was calculated to be sufficient to break free from Earth\u2019s gravitational field, and the reentry velocity was carefully controlled to ensure a safe landing back on Earth. Satellite Deployment : The deployment of the International Space Station (ISS) involved launching multiple payloads into low Earth orbit (LEO) at a specific velocity and altitude. These satellites had to be deployed at the correct time and velocity to match the ISS\u2019s orbit, ensuring their correct insertion into orbit. The precision in calculating the payload's trajectory was critical for both successful orbital insertion and reentry. The correct trajectory also ensured that the deployed satellites would remain operational for their intended missions.","title":"Case Studies and Historical Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion_1","text":"The concepts of escape velocity, orbital insertion, and trajectory analysis are foundational in space exploration and satellite deployment. Understanding these principles allows for the successful launch, deployment, and reentry of payloads, making them vital for future space missions, including Mars exploration, lunar missions, and the growing field of satellite-based communications and earth observation.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Patterns on a Water Surface 1. Selecting a Regular Polygon Introduction In wave physics, interference occurs when two or more waves overlap, resulting in regions of constructive and destructive interference. To systematically analyze these patterns, we consider multiple point wave sources positioned at the vertices of a regular polygon . This setup allows us to explore how symmetric arrangements of sources influence the resulting wave field. Mathematical Definition of a Regular Polygon A regular polygon with \\(N\\) sides is a closed geometric figure where all sides are of equal length and all internal angles are equal. The vertices of such a polygon, when inscribed in a circle of radius \\(R\\) , can be determined using trigonometric functions. For a polygon centered at the origin, the coordinates of the \\(i\\) -th vertex are given by: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] where: - \\(R\\) is the circumradius of the polygon, \\(N\\) is the number of sides (hence, the number of sources), \\(i\\) indexes the vertices counterclockwise starting from an initial reference point. Choosing the Regular Polygon The choice of \\(N\\) influences the symmetry of the interference pattern. Common selections include: Equilateral Triangle ( \\(N=3\\) ) : Yields a threefold symmetric interference pattern. Square ( \\(N=4\\) ) : Produces a fourfold symmetric pattern with central and diagonal wave reinforcements. Pentagon ( \\(N=5\\) ) : Generates more complex wave interactions with fivefold rotational symmetry. Hexagon ( \\(N=6\\) ) : Approximates circular symmetry while retaining noticeable interference fringes. 2. Positioning the Sources Determining the Coordinates of the Polygonal Vertices To systematically analyze interference, we must precisely position the wave sources at the vertices of a chosen regular polygon. Given a polygon inscribed within a circle of radius \\(R\\) , the coordinates of its vertices are: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] Assigning Each Vertex as a Wave Source Each vertex serves as a point source emitting circular waves with identical amplitude and frequency. The total wave field results from the superposition of these waves. Each wave propagates outward from its source with a displacement function: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}\\) is the radial distance to the observation point. 3. Defining the Wave Equations Mathematical Representation of Wave Motion Each wave emitted from a point source follows the equation: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(A\\) is the amplitude, \\(k=\\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega=2\\pi f\\) is the angular frequency, \\(\\phi_i\\) is the phase, \\(r_i\\) is the radial distance from the \\(i\\) -th source. Uniformity Assumptions To maintain coherence in interference analysis, we assume: All waves have the same amplitude , i.e., \\(A\\) is constant. All waves have the same wavelength \\(\\lambda\\) and frequency \\(f\\) . Initial phase differences between sources remain fixed. 4. Applying the Superposition Principle Summation of Wave Displacements According to the principle of superposition, the resultant displacement at any point on the water surface is the sum of individual wave contributions: \\[\\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t)\\] This summation captures constructive and destructive interference effects. Constructive and Destructive Interference Conditions Constructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=2m\\pi,\\quad m\\in\\mathbb{Z}\\] Destructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=(2m+1)\\pi,\\quad m\\in\\mathbb{Z}\\] 5. Analyzing the Interference Patterns Identifying Interference Zones By computing \\(\\eta_{\\text{sum}}(x,y,t)\\) , we can classify different regions: - High amplitude zones: Result from constructive interference. - Low amplitude zones: Result from destructive interference. Temporal Evolution of the Pattern As time progresses, the interference pattern evolves dynamically, influenced by wave frequency and phase differences. 6. Visualization and Simulation Graphical Representations Using numerical simulations, we generate: - Static interference maps for different polygons. - Time-evolving wave fields to observe changing interference dynamics. Python Implementation A Python script implementing the above equations will: 1. Define wave parameters. 2. Compute the interference pattern on a 2D grid. 3. Visualize results using heatmaps and contour plots. The next step is to implement and analyze these interference patterns computationally. Python/Models GIF For 5 sources GIF Code import numpy as np import matplotlib.pyplot as plt import imageio # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency # Function to create a wave from a single source def single_wave(X, Y, source, t): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources, t): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source, t) return Z # Sources definitions for 5 sources (in a pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create GIF frames num_frames = 100 gif_frames = [] # Create the GIF frames for time from 0 to 2*pi for i in range(num_frames): t = i * 2 * np.pi / num_frames # Varying time Z = multiple_waves(X, Y, sources_5, t) # Plotting the frame fig, ax = plt.subplots(figsize=(8, 6)) im = ax.imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis', animated=True) ax.set_title(f\"Interference of 5 Sources - Time = {t:.2f}\", fontsize=16) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=ax) # Ensure proper rendering plt.tight_layout() # Draw the figure to make sure it's rendered correctly before saving fig.canvas.draw() # Convert to image and append to GIF frames gif_frames.append(np.array(fig.canvas.renderer.buffer_rgba())) # Close the plot to avoid memory issues in the loop plt.close(fig) # Create and save the GIF imageio.mimsave('interference_5_sources.gif', gif_frames, duration=0.1) print(\"GIF saved as 'interference_5_sources.gif'\") Colab import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis') axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() plt.show() # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\") Colab","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-patterns-on-a-water-surface","text":"","title":"Wave Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-selecting-a-regular-polygon","text":"","title":"1. Selecting a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"In wave physics, interference occurs when two or more waves overlap, resulting in regions of constructive and destructive interference. To systematically analyze these patterns, we consider multiple point wave sources positioned at the vertices of a regular polygon . This setup allows us to explore how symmetric arrangements of sources influence the resulting wave field.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-definition-of-a-regular-polygon","text":"A regular polygon with \\(N\\) sides is a closed geometric figure where all sides are of equal length and all internal angles are equal. The vertices of such a polygon, when inscribed in a circle of radius \\(R\\) , can be determined using trigonometric functions. For a polygon centered at the origin, the coordinates of the \\(i\\) -th vertex are given by: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] where: - \\(R\\) is the circumradius of the polygon, \\(N\\) is the number of sides (hence, the number of sources), \\(i\\) indexes the vertices counterclockwise starting from an initial reference point.","title":"Mathematical Definition of a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#choosing-the-regular-polygon","text":"The choice of \\(N\\) influences the symmetry of the interference pattern. Common selections include: Equilateral Triangle ( \\(N=3\\) ) : Yields a threefold symmetric interference pattern. Square ( \\(N=4\\) ) : Produces a fourfold symmetric pattern with central and diagonal wave reinforcements. Pentagon ( \\(N=5\\) ) : Generates more complex wave interactions with fivefold rotational symmetry. Hexagon ( \\(N=6\\) ) : Approximates circular symmetry while retaining noticeable interference fringes.","title":"Choosing the Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-positioning-the-sources","text":"","title":"2. Positioning the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#determining-the-coordinates-of-the-polygonal-vertices","text":"To systematically analyze interference, we must precisely position the wave sources at the vertices of a chosen regular polygon. Given a polygon inscribed within a circle of radius \\(R\\) , the coordinates of its vertices are: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\]","title":"Determining the Coordinates of the Polygonal Vertices"},{"location":"1%20Physics/3%20Waves/Problem_1/#assigning-each-vertex-as-a-wave-source","text":"Each vertex serves as a point source emitting circular waves with identical amplitude and frequency. The total wave field results from the superposition of these waves. Each wave propagates outward from its source with a displacement function: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}\\) is the radial distance to the observation point.","title":"Assigning Each Vertex as a Wave Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-defining-the-wave-equations","text":"","title":"3. Defining the Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-representation-of-wave-motion","text":"Each wave emitted from a point source follows the equation: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(A\\) is the amplitude, \\(k=\\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega=2\\pi f\\) is the angular frequency, \\(\\phi_i\\) is the phase, \\(r_i\\) is the radial distance from the \\(i\\) -th source.","title":"Mathematical Representation of Wave Motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#uniformity-assumptions","text":"To maintain coherence in interference analysis, we assume: All waves have the same amplitude , i.e., \\(A\\) is constant. All waves have the same wavelength \\(\\lambda\\) and frequency \\(f\\) . Initial phase differences between sources remain fixed.","title":"Uniformity Assumptions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-applying-the-superposition-principle","text":"","title":"4. Applying the Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#summation-of-wave-displacements","text":"According to the principle of superposition, the resultant displacement at any point on the water surface is the sum of individual wave contributions: \\[\\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t)\\] This summation captures constructive and destructive interference effects.","title":"Summation of Wave Displacements"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-and-destructive-interference-conditions","text":"Constructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=2m\\pi,\\quad m\\in\\mathbb{Z}\\] Destructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=(2m+1)\\pi,\\quad m\\in\\mathbb{Z}\\]","title":"Constructive and Destructive Interference Conditions"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyzing-the-interference-patterns","text":"","title":"5. Analyzing the Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#identifying-interference-zones","text":"By computing \\(\\eta_{\\text{sum}}(x,y,t)\\) , we can classify different regions: - High amplitude zones: Result from constructive interference. - Low amplitude zones: Result from destructive interference.","title":"Identifying Interference Zones"},{"location":"1%20Physics/3%20Waves/Problem_1/#temporal-evolution-of-the-pattern","text":"As time progresses, the interference pattern evolves dynamically, influenced by wave frequency and phase differences.","title":"Temporal Evolution of the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualization-and-simulation","text":"","title":"6. Visualization and Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#graphical-representations","text":"Using numerical simulations, we generate: - Static interference maps for different polygons. - Time-evolving wave fields to observe changing interference dynamics.","title":"Graphical Representations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"A Python script implementing the above equations will: 1. Define wave parameters. 2. Compute the interference pattern on a 2D grid. 3. Visualize results using heatmaps and contour plots. The next step is to implement and analyze these interference patterns computationally.","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#pythonmodels","text":"","title":"Python/Models"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#gif-for-5-sources","text":"","title":"GIF For 5 sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#_4","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#gif-code","text":"import numpy as np import matplotlib.pyplot as plt import imageio # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency # Function to create a wave from a single source def single_wave(X, Y, source, t): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources, t): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source, t) return Z # Sources definitions for 5 sources (in a pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create GIF frames num_frames = 100 gif_frames = [] # Create the GIF frames for time from 0 to 2*pi for i in range(num_frames): t = i * 2 * np.pi / num_frames # Varying time Z = multiple_waves(X, Y, sources_5, t) # Plotting the frame fig, ax = plt.subplots(figsize=(8, 6)) im = ax.imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis', animated=True) ax.set_title(f\"Interference of 5 Sources - Time = {t:.2f}\", fontsize=16) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=ax) # Ensure proper rendering plt.tight_layout() # Draw the figure to make sure it's rendered correctly before saving fig.canvas.draw() # Convert to image and append to GIF frames gif_frames.append(np.array(fig.canvas.renderer.buffer_rgba())) # Close the plot to avoid memory issues in the loop plt.close(fig) # Create and save the GIF imageio.mimsave('interference_5_sources.gif', gif_frames, duration=0.1) print(\"GIF saved as 'interference_5_sources.gif'\")","title":"GIF Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#colab","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap='viridis') axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() plt.show() # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\") Colab","title":"Colab"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Lorentz Force on a Charged Particle \ud83d\udccc Introduction The motion of a charged particle in electric and magnetic fields is governed by the Lorentz Force : \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This principle underpins key technologies such as: Cyclotrons Mass spectrometers Magnetic traps Plasma confinement in fusion reactors \u2699\ufe0f Physical Parameters To generate meaningful macroscopic simulations, we use: Charge: \\(q = 1\\, \\mathrm{C}\\) Mass: \\(m = 0.001\\, \\mathrm{kg}\\) (i.e. \\(1\\, \\mathrm{g}\\) ) Time interval: suitable range for visible motion (e.g., \\(10^{-3}\\, \\mathrm{s}\\) ) Vector fields: Electric field \\(\\mathbf{E}\\) Magnetic field \\(\\mathbf{B}\\) Initial velocity \\(\\mathbf{v}_0\\) \ud83d\udcd0 Equations of Motion We solve the following system of ODEs numerically: Let \\(\\mathbf{r}\\) be position, \\(\\mathbf{v}\\) be velocity: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] We integrate this using Python's solve_ivp() method. \ud83d\udd2d Scenarios and Trajectories We simulate three representative cases: 1\ufe0f\u20e3 Circular Motion Fields: \\(\\mathbf{E} = \\mathbf{0}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: perpendicular to \\(\\mathbf{B}\\) Expected behavior: - Uniform circular motion in the \\(xy\\) -plane - Radius: Larmor radius \\[ R = \\frac{mv}{qB} \\] 2\ufe0f\u20e3 Helical (Spiral) Motion Fields: \\(\\mathbf{E} = \\mathbf{0}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: not fully perpendicular (has \\(z\\) -component) Expected behavior: - Helical motion spiraling along \\(\\mathbf{B}\\) -field - Constant axial drift along \\(z\\) 3\ufe0f\u20e3 Crossed Fields Drift Fields: \\(\\mathbf{E} = (10, 0, 0)\\, \\mathrm{V/m}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: arbitrary Expected behavior: - Drift velocity: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] Trajectory shows sideways drift and possible curvature \ud83c\udfa8 Visualizations For each scenario: \u2705 2D and 3D plots of trajectories \u2705 Animation (GIF) \u2705 Highlights: Larmor radius Direction of drift Spiral axis \u2705 Color-coded motion paths with labeled axes and time markers \ud83e\udde0 Observations The magnetic field introduces circular or spiral constraints Electric field induces linear acceleration or drift Field configurations can be designed to trap or accelerate particles \ud83e\uddf0 Code Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Time settings t_span = (0, 10) t_eval = np.linspace(t_span[0], t_span[1], 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[0], sol.y[1], sol.y[2] # Set up the figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Charged Particle Motion in 2D (x-y plane)\") ax.grid(True) line, = ax.plot([], [], lw=2, color='dodgerblue') point, = ax.plot([], [], 'ro') # Init function def init(): line.set_data([], []) point.set_data([], []) return line, point # Update function def update(i): if i < len(x): # Ensure index is valid line.set_data(x[:i+1], y[:i+1]) point.set_data([x[i]], [y[i]]) # Use lists to ensure sequence return line, point return line, point # Create animation ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # Save to GIF with explicit writer settings gif_path = \"charged_particle_motion.gif\" writer = PillowWriter(fps=30) ani.save(gif_path, writer=writer, dpi=100) plt.close() # Display the GIF in Colab display(Image(filename=gif_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 1.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Solve system t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[0], sol.y[1], sol.y[2] t = sol.t # 3D Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, lw=2.5, c='gray', alpha=0.3) scatter = ax.scatter(x, y, z, c=t, cmap='viridis', s=2) ax.scatter(x[0], y[0], z[0], color='lime', label='Start', s=60) ax.scatter(x[-1], y[-1], z[-1], color='red', label='End', s=60) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('3D Trajectory of a Charged Particle\\nin Electric & Magnetic Fields', weight='bold', fontsize=14) ax.legend() fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.6, pad=0.1) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Time array t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # Build color gradient segments points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) lc = LineCollection(segments, cmap='plasma', norm=norm) lc.set_array(t_eval) lc.set_linewidth(2.5) # Plot fig, ax = plt.subplots(figsize=(8, 6)) ax.add_collection(lc) ax.scatter(x[0], y[0], color='lime', label='Start', zorder=5) ax.scatter(x[-1], y[-1], color='red', label='End', zorder=5) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Color Gradient Trajectory of Charged Particle', weight='bold') ax.axis('equal') ax.legend() plt.colorbar(lc, ax=ax, label='Time (s)') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge m = 1.0 # Mass # Electric and magnetic fields E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Lorentz force def lorentz(t, y): r = y[:3] v = y[3:] drdt = v dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((drdt, dvdt)) # Time span t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) y0 = np.concatenate((r0, v0)) # Solve ODE solution = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) r = solution.y[:3] # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d', facecolor='black') # Drift motion (orange line) ax.plot3D(r[0], r[1], r[2], color='orange', lw=2, label='Drift Motion') # Style ax.set_facecolor('black') ax.grid(True, color='gray', linestyle='--', linewidth=0.5) ax.set_title(\"Drift Motion in E and B Fields\", fontsize=14, color='white', weight='bold') ax.set_xlabel(\"x (m)\", color='white') ax.set_ylabel(\"y (m)\", color='white') ax.set_zlabel(\"z (m)\", color='white') ax.tick_params(colors='white') ax.legend(facecolor='black', edgecolor='white', labelcolor='white') plt.tight_layout() plt.show()","title":"Simulating the Lorentz Force on a Charged Particle"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-lorentz-force-on-a-charged-particle","text":"","title":"Simulating the Lorentz Force on a Charged Particle"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The motion of a charged particle in electric and magnetic fields is governed by the Lorentz Force : \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] This principle underpins key technologies such as: Cyclotrons Mass spectrometers Magnetic traps Plasma confinement in fusion reactors","title":"\ud83d\udccc Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-parameters","text":"To generate meaningful macroscopic simulations, we use: Charge: \\(q = 1\\, \\mathrm{C}\\) Mass: \\(m = 0.001\\, \\mathrm{kg}\\) (i.e. \\(1\\, \\mathrm{g}\\) ) Time interval: suitable range for visible motion (e.g., \\(10^{-3}\\, \\mathrm{s}\\) ) Vector fields: Electric field \\(\\mathbf{E}\\) Magnetic field \\(\\mathbf{B}\\) Initial velocity \\(\\mathbf{v}_0\\)","title":"\u2699\ufe0f Physical Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equations-of-motion","text":"We solve the following system of ODEs numerically: Let \\(\\mathbf{r}\\) be position, \\(\\mathbf{v}\\) be velocity: \\[ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\] \\[ \\frac{d\\mathbf{v}}{dt} = \\frac{q}{m} \\left( \\mathbf{E} + \\mathbf{v} \\times \\mathbf{B} \\right) \\] We integrate this using Python's solve_ivp() method.","title":"\ud83d\udcd0 Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios-and-trajectories","text":"We simulate three representative cases:","title":"\ud83d\udd2d Scenarios and Trajectories"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-circular-motion","text":"Fields: \\(\\mathbf{E} = \\mathbf{0}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: perpendicular to \\(\\mathbf{B}\\) Expected behavior: - Uniform circular motion in the \\(xy\\) -plane - Radius: Larmor radius \\[ R = \\frac{mv}{qB} \\]","title":"1\ufe0f\u20e3 Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-helical-spiral-motion","text":"Fields: \\(\\mathbf{E} = \\mathbf{0}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: not fully perpendicular (has \\(z\\) -component) Expected behavior: - Helical motion spiraling along \\(\\mathbf{B}\\) -field - Constant axial drift along \\(z\\)","title":"2\ufe0f\u20e3 Helical (Spiral) Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-crossed-fields-drift","text":"Fields: \\(\\mathbf{E} = (10, 0, 0)\\, \\mathrm{V/m}\\) \\(\\mathbf{B} = (0, 0, 1)\\, \\mathrm{T}\\) Initial velocity: arbitrary Expected behavior: - Drift velocity: \\[ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] Trajectory shows sideways drift and possible curvature","title":"3\ufe0f\u20e3 Crossed Fields Drift"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualizations","text":"","title":"\ud83c\udfa8 Visualizations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#for-each-scenario","text":"","title":"For each scenario:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_3","text":"\u2705 2D and 3D plots of trajectories \u2705 Animation (GIF) \u2705 Highlights: Larmor radius Direction of drift Spiral axis \u2705 Color-coded motion paths with labeled axes and time markers","title":""},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations","text":"The magnetic field introduces circular or spiral constraints Electric field induces linear acceleration or drift Field configurations can be designed to trap or accelerate particles","title":"\ud83e\udde0 Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Time settings t_span = (0, 10) t_eval = np.linspace(t_span[0], t_span[1], 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[0], sol.y[1], sol.y[2] # Set up the figure fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_title(\"Charged Particle Motion in 2D (x-y plane)\") ax.grid(True) line, = ax.plot([], [], lw=2, color='dodgerblue') point, = ax.plot([], [], 'ro') # Init function def init(): line.set_data([], []) point.set_data([], []) return line, point # Update function def update(i): if i < len(x): # Ensure index is valid line.set_data(x[:i+1], y[:i+1]) point.set_data([x[i]], [y[i]]) # Use lists to ensure sequence return line, point return line, point # Create animation ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # Save to GIF with explicit writer settings gif_path = \"charged_particle_motion.gif\" writer = PillowWriter(fps=30) ani.save(gif_path, writer=writer, dpi=100) plt.close() # Display the GIF in Colab display(Image(filename=gif_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 1.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Solve system t_span = (0, 10) t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y, z = sol.y[0], sol.y[1], sol.y[2] t = sol.t # 3D Plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, lw=2.5, c='gray', alpha=0.3) scatter = ax.scatter(x, y, z, c=t, cmap='viridis', s=2) ax.scatter(x[0], y[0], z[0], color='lime', label='Start', s=60) ax.scatter(x[-1], y[-1], z[-1], color='red', label='End', s=60) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('3D Trajectory of a Charged Particle\\nin Electric & Magnetic Fields', weight='bold', fontsize=14) ax.legend() fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.6, pad=0.1) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection # Constants q = 1.0 m = 1.0 E = np.array([0.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) # Initial conditions v0 = np.array([1.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) y0 = np.concatenate((r0, v0)) # Lorentz force function def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # Time array t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # Build color gradient segments points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) lc = LineCollection(segments, cmap='plasma', norm=norm) lc.set_array(t_eval) lc.set_linewidth(2.5) # Plot fig, ax = plt.subplots(figsize=(8, 6)) ax.add_collection(lc) ax.scatter(x[0], y[0], color='lime', label='Start', zorder=5) ax.scatter(x[-1], y[-1], color='red', label='End', zorder=5) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Color Gradient Trajectory of Charged Particle', weight='bold') ax.axis('equal') ax.legend() plt.colorbar(lc, ax=ax, label='Time (s)') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge m = 1.0 # Mass # Electric and magnetic fields E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Lorentz force def lorentz(t, y): r = y[:3] v = y[3:] drdt = v dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((drdt, dvdt)) # Time span t_span = (0, 20) t_eval = np.linspace(t_span[0], t_span[1], 1000) y0 = np.concatenate((r0, v0)) # Solve ODE solution = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) r = solution.y[:3] # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d', facecolor='black') # Drift motion (orange line) ax.plot3D(r[0], r[1], r[2], color='orange', lw=2, label='Drift Motion') # Style ax.set_facecolor('black') ax.grid(True, color='gray', linestyle='--', linewidth=0.5) ax.set_title(\"Drift Motion in E and B Fields\", fontsize=14, color='white', weight='bold') ax.set_xlabel(\"x (m)\", color='white') ax.set_ylabel(\"y (m)\", color='white') ax.set_zlabel(\"z (m)\", color='white') ax.tick_params(colors='white') ax.legend(facecolor='black', edgecolor='white', labelcolor='white') plt.tight_layout() plt.show()","title":"\ud83e\uddf0 Code Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udcd8 Phase 1: Understanding the Concepts \ud83d\udd0c Equivalent Resistance Rules Understanding how resistors combine is fundamental before translating circuits into graph models. \u2795 Series Connection Resistors are in series if they are connected end-to-end with no branching. The equivalent resistance is the sum of the individual resistances: \\[ R_{\\text{eq(series)}} = R_1 + R_2 + R_3 + \\dots + R_n \\] Current through each resistor is the same. Voltage divides across resistors. \ud83d\udd01 Parallel Connection Resistors are in parallel if both ends are connected to the same two nodes. The reciprocal of the equivalent resistance is the sum of reciprocals: \\[ \\frac{1}{R_{\\text{eq(parallel)}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\frac{1}{R_3} + \\dots + \\frac{1}{R_n} \\] Voltage across each resistor is the same. Current divides among the resistors. \ud83d\udcc8 Circuit-to-Graph Mapping To apply graph theory, we convert the electrical circuit into a mathematical graph: Nodes represent junctions in the circuit. Edges represent resistors , with the edge weight equal to the resistor\u2019s resistance (in ohms, \\(\\Omega\\) ). \ud83e\udde0 Key Concepts A resistor between two junctions is modeled as an undirected weighted edge between two nodes. The full circuit becomes a weighted undirected graph \\(G = (V, E)\\) , where: \\(V\\) is the set of junctions (vertices), \\(E\\) is the set of resistors (edges with weights). \u2705 Benefits of Graph Representation Structured and algorithmic simplification. Supports complex topologies and nested resistor configurations. Enables usage of algorithms from graph theory , such as traversal, cycle detection, and graph reduction. \ud83e\udded Summary By understanding how resistors combine and how to represent circuits as graphs, we lay the groundwork for designing an algorithm that can automate the process of finding equivalent resistance\u2014even in complex, nested networks. \u2705 Phase 2: Develop the Algorithm (Conceptual Level) \ud83d\udd0d Objective We aim to design an algorithm that calculates the equivalent resistance of a complex circuit represented as a graph . The method must iteratively detect , simplify , and combine resistors until the graph reduces to a single equivalent resistance between two terminals. \ud83e\udde0 Key Concepts \u2795 Series Connection Detection A series configuration occurs when: Two resistors share a common node of degree 2 . No branching occurs at this node. The equivalent resistance for series: $$ R_{\\text{eq}} = R_1 + R_2 $$ \ud83d\udd01 Parallel Connection Detection A parallel configuration exists when: Multiple edges connect the same pair of nodes . The equivalent resistance for parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\] \ud83d\udd01 Iterative Graph Simplification We apply the following logic iteratively until the entire graph reduces to a single edge representing the total equivalent resistance: Detect series resistor pairs and combine. Detect parallel resistor groups and combine. Replace each group with its equivalent resistance . Repeat until no more simplifications are possible. \ud83e\uddfe Pseudocode: Resistance Reduction Algorithm function compute_equivalent_resistance(graph G): while G has more than two nodes: for each node v in G: if degree(v) == 2: u, w = neighbors of v if edge(u, v) and edge(v, w) exist: R1 = weight of edge(u, v) R2 = weight of edge(v, w) replace with edge(u, w) with weight R1 + R2 remove node v and its incident edges for each pair of nodes (u, v): if multiple edges exist between u and v: Let R1, R2, ..., Rn be the weights of all edges(u, v) compute R_eq using: 1 / R_eq = 1 / R1 + 1 / R2 + ... + 1 / Rn replace all edges(u, v) with a single edge of weight R_eq return weight of final edge between terminals \ud83d\udd04 Handling Nested Combinations Nested structures (e.g. series within parallel) are simplified recursively or by repeated iteration . The graph is dynamically updated: Merging two resistors may enable a new parallel pattern. Re-check after each merge. \u2705 Summary This algorithm provides a robust and scalable method for calculating the equivalent resistance in arbitrary networks by: Modeling the circuit as a graph. Identifying structural patterns (series, parallel). Reducing them iteratively using physics-based rules. The approach is suitable for both manual analysis and automated implementations in tools like Python with networkx . \u2705 Phase 3: Work on Examples \ud83d\udd0d Goal To demonstrate how the algorithm simplifies real-world circuit cases, we analyze three examples : Pure Series Resistors Pure Parallel Resistors Nested Configuration (Series and Parallel combined) Each example includes a description, circuit logic, and a step-by-step simplification. \ud83d\udd38 Example 1: Series Resistors \ud83e\udde9 Description Three resistors connected in series between two nodes A and D. Components : \\(R_1 = 5\\ \\Omega\\) \\(R_2 = 10\\ \\Omega\\) \\(R_3 = 15\\ \\Omega\\) Connection : A \u2014 R\u2081 \u2014 B \u2014 R\u2082 \u2014 C \u2014 R\u2083 \u2014 D \u2699\ufe0f Simplification Logic Series resistors are linearly connected : \\[ R_{\\text{eq}} = R_1 + R_2 + R_3 = 5 + 10 + 15 = 30\\ \\Omega \\] Algorithm detects each degree-2 node and collapses them iteratively: Combine A\u2013B and B\u2013C into A\u2013C Then combine A\u2013C and C\u2013D into A\u2013D \ud83d\udd38 Example 2: Parallel Resistors \ud83e\udde9 Description Two resistors connected in parallel between nodes A and B. Components : \\(R_1 = 10\\ \\Omega\\) \\(R_2 = 20\\ \\Omega\\) Connection : Path 1: A \u2192 R\u2081 \u2192 B Path 2: A \u2192 R\u2082 \u2192 B \u2699\ufe0f Simplification Logic Parallel resistors are connected across the same two nodes : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\Rightarrow R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\ \\Omega \\] Algorithm groups all edges between A and B, replaces them with the calculated equivalent resistance. \ud83d\udd38 Example 3: Nested Configuration (Series + Parallel) \ud83e\udde9 Description \\(R_1 = 5\\ \\Omega\\) (A \u2192 B) \\(R_2 = 10\\ \\Omega\\) (B \u2192 C) \\(R_3 = 20\\ \\Omega\\) (B \u2192 C) \u2014 parallel to R\u2082 \\(R_4 = 5\\ \\Omega\\) (C \u2192 D) \ud83d\udee0 Structure: A \u2014 R\u2081 \u2014 B B \u2192 R\u2082 \u2192 C B \u2192 R\u2083 \u2192 C (in parallel with R\u2082) C \u2192 R\u2084 \u2192 D \u2699\ufe0f Simplification Logic Parallel between B\u2013C : $$ \\frac{1}{R_{BC}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\Rightarrow R_{BC} = \\frac{20}{3} \\approx 6.67\\ \\Omega $$ New path becomes: A \u2014 R\u2081 \u2014 B \u2014 \\(R_{BC}\\) \u2014 C \u2014 R\u2084 \u2014 D Series total : \\[ R_{\\text{eq}} = R_1 + R_{BC} + R_4 = 5 + \\frac{20}{3} + 5 = \\frac{50}{3} \\approx 16.67\\ \\Omega \\] The algorithm reduces: Parallel group \u2192 replaces with \\(R_{BC}\\) Remaining series \u2192 collapsed step-by-step Visual \u2705 Summary Type Formula Used Result Series \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) \\(30\\ \\Omega\\) Parallel \\(\\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i}\\) \\(6.67\\ \\Omega\\) Nested Series + Parallel combination \\(16.67\\ \\Omega\\) These examples validate how graph-based simplification can be used to iteratively reduce circuits of arbitrary complexity using consistent rules and clear patterns. \u2705 Phase 4: Analyze the Algorithm \ud83d\udcca Efficiency Evaluation Understanding the computational efficiency of the graph-based resistance simplification algorithm is key for scaling to large networks. \ud83d\udd04 Number of Steps Let \\(n\\) be the number of nodes , and \\(m\\) be the number of edges (resistors). In the worst case , the algorithm performs: \\(O(n)\\) passes for series simplifications. \\(O(m)\\) checks for parallel edge reductions. \ud83d\udcc9 Complexity of Series/Parallel Detection \u2795 Series Detection: For each node \\(v\\) : Check if \\(\\text{deg}(v) = 2\\) Cost: \\(O(n)\\) per pass If two neighbors \\(u\\) and \\(w\\) are connected to \\(v\\) : Combine \\(R_{uv}\\) and \\(R_{vw}\\) into \\(R_{uw}\\) Time per operation: \\(O(1)\\) Total complexity (series-only): \\(O(n^2)\\) in worst case due to repeated passes. \ud83d\udd01 Parallel Detection: For each unordered pair of nodes \\((u, v)\\) : Collect all edges between them: \\(O(m)\\) Reduce them using: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^{k} \\frac{1}{R_i} \\] Total complexity (parallel-only): \\(O(m^2)\\) worst case for densely connected graphs. \u26a0\ufe0f Limitations \ud83e\udde9 Edge Cases & Complex Cycles The current algorithm assumes: Graph is connected . No dependent sources or nonlinear elements (e.g., capacitors, inductors). Bridging nodes (nodes that are part of multiple paths) may delay detection of simplification patterns. Circuits with cycles that are not purely parallel can be harder to simplify without advanced techniques (e.g., mesh analysis). \ud83d\udcc8 Visualization \u2705 Summary Aspect Summary Series Detection Fast per step, repeated passes required ( \\(O(n^2)\\) worst case) Parallel Detection Simple but costly in dense graphs ( \\(O(m^2)\\) worst case) Limitations Cannot directly solve meshes, bridges, or nonlinear elements Improvements DFS, union-find, real-time animation, and better data structures This phase ensures the algorithm isn't just correct , but also efficient , scalable , and educationally valuable in practice. Python Codes import matplotlib.pyplot as plt import matplotlib.patches as patches import matplotlib.animation as animation # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R5\": 50, \"R23\": 1 / (1 / 20 + 1 / 30), \"R45\": 40 + 50, \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), \"R12345\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 + 50 } positions = { \"B+\": (0, 2), \"R1\": (2, 0.5), \"R2\": (2, 3.5), \"R3\": (4, 3.5), \"R4\": (6, 2), \"R5\": (8, 2), \"R23\": (3, 3.5), \"R45\": (7, 2), \"R123\": (3, 2), \"R12345\": (4.5, 2), \"B-\": (10, 2) } steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Circuit\", \"boxes\": [\"B+\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [], \"label_lines\": { (\"B+\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"R4\"): \"R4\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R23 = (R2 || R3) = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: Combine R2 || R3 \u2192 R23\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R45 = R4 + R5 = 90.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: Combine R4 + R5 \u2192 R45\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"B+\", \"R1\"), (\"R1\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R45\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R45\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R45\"): \"R4\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R123 = R1 + R23 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 3: Combine R1 + R23 \u2192 R123\", \"boxes\": [\"B+\", \"R123\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"B+\", \"R123\"): \"R123\", (\"R123\", \"R45\"): \"R123\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R12345 = R123 + R45 = 112.00\u03a9\" }, { \"title\": \"\u2705 Final Result: R12345\", \"boxes\": [\"B+\", \"R12345\", \"B-\"], \"lines\": [(\"B+\", \"R12345\"), (\"R12345\", \"B-\")], \"highlight\": [\"R12345\"], \"label_lines\": { (\"B+\", \"R12345\"): \"R12345\", (\"R12345\", \"B-\"): \"R12345\" }, \"formula\": \"R_eq = 112.00\u03a9\" } ] highlight_colors = { \"R23\": \"#FF6F61\", \"R45\": \"#76D7C4\", \"R123\": \"#85C1E9\", \"R12345\": \"#DDA0DD\" } # Draw frame for animation def draw_frame(i): step = steps[i] ax.clear() ax.set_xlim(-1, 11) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if \"label_lines\" in step: key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"].get(key) if rname and rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.5, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') # Create the animation fig, ax = plt.subplots(figsize=(11, 4.5)) ani = animation.FuncAnimation(fig, draw_frame, frames=len(steps), interval=1500, repeat=True) # Save to GIF gif_path = \"/content/circuit_simplification.gif\" ani.save(gif_path, writer=\"pillow\", fps=1) from IPython.display import Image Image(filename=gif_path) # \u2705 Final Clean Circuit Diagrams with Small Fonts and Beautiful Layout import matplotlib.pyplot as plt import matplotlib.patches as patches # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"Req_series\": 10 + 20 + 30, \"Req_parallel\": 1 / (1 / 10 + 1 / 20) } # Layouts with wider spacing positions_series = { \"A\": (0, 2), \"R1\": (2, 2), \"R2\": (4, 2), \"R3\": (6, 2), \"Req\": (4, 2), \"B\": (8, 2) } positions_parallel = { \"A\": (0, 2), \"R1\": (2, 3.2), \"R2\": (2, 0.8), \"Req\": (2, 2), \"B\": (4, 2) } highlight_colors = {\"Req\": \"#BB8FCE\"} line_labels_series = { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"B\"): \"R3\" } line_labels_parallel = { (\"A\", \"R1\"): \"R1\", (\"R1\", \"B\"): \"R1\", (\"A\", \"R2\"): \"R2\", (\"R2\", \"B\"): \"R2\" } # Drawing function def draw_valued_circuit(title, boxes, lines, highlight=[], positions=None, line_labels=None, note=\"\", formula=\"\"): fig, ax = plt.subplots(figsize=(11, 5)) ax.set_xlim(-1, 9) ax.set_ylim(-0.5, 5.5) ax.axis(\"off\") ax.set_title(title, fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") # Boxes for box in boxes: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in highlight else \"#F2F4F4\" rect = patches.FancyBboxPatch( (x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=1.8 ) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight='bold', color=\"#34495E\") # Arrows + edge labels for u, v in lines: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if line_labels: key = (u, v) if (u, v) in line_labels else (v, u) if key in line_labels: rname = line_labels[key] if rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" offset = 0.25 if abs(y2 - y1) < 0.1 else 0.15 ax.text(mx, my + offset, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.2, note, fontsize=9, style='italic', color='gray') ax.text(0, -0.45, formula, fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # Values R1, R2, R3 = resistor_values[\"R1\"], resistor_values[\"R2\"], resistor_values[\"R3\"] R_eq_series = resistor_values[\"Req_series\"] R_eq_parallel = resistor_values[\"Req_parallel\"] # Series Step 1 draw_valued_circuit( \"\ud83d\udd30 Series Connection \u2013 Step 1\", [\"A\", \"R1\", \"R2\", \"R3\", \"B\"], [(\"A\", \"R1\"), (\"R1\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"B\")], positions=positions_series, line_labels=line_labels_series, note=\"Three resistors connected in series.\", formula=f\"R_eq = {R1}\u03a9 + {R2}\u03a9 + {R3}\u03a9 = {R_eq_series:.2f}\u03a9\" ) # Series Step 2 draw_valued_circuit( \"\u2705 Series Connection \u2013 Step 2: Simplified Req\", [\"A\", \"Req\", \"B\"], [(\"A\", \"Req\"), (\"Req\", \"B\")], highlight=[\"Req\"], positions=positions_series, note=\"Replaced with equivalent Req.\", formula=f\"R_eq = {R_eq_series:.2f}\u03a9\" ) # Parallel Step 1 draw_valued_circuit( \"\ud83d\udd30 Parallel Connection \u2013 Step 1\", [\"A\", \"R1\", \"R2\", \"B\"], [(\"A\", \"R1\"), (\"R1\", \"B\"), (\"A\", \"R2\"), (\"R2\", \"B\")], positions=positions_parallel, line_labels=line_labels_parallel, note=\"Two resistors connected in parallel.\", formula=f\"1/R_eq = 1/{R1} + 1/{R2} \u2192 R_eq = {R_eq_parallel:.2f}\u03a9\" ) # Parallel Step 2 draw_valued_circuit( \"\u2705 Parallel Connection \u2013 Step 2: Simplified Req\", [\"A\", \"Req\", \"B\"], [(\"A\", \"Req\"), (\"Req\", \"B\")], highlight=[\"Req\"], positions=positions_parallel, note=\"Replaced with equivalent Req.\", formula=f\"R_eq = {R_eq_parallel:.2f}\u03a9\" ) # \u2705 Final Nested Circuit Simplification with R = xx\u03a9 Labels (Colab-ready) import matplotlib.pyplot as plt import matplotlib.patches as patches # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R23\": 1 / (1 / 20 + 1 / 30), \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), \"R1234\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 } # Node positions positions = { \"A\": (0, 2), \"R1\": (1.5, 2), \"R2\": (3, 3.5), \"R3\": (3, 0.5), \"R23\": (3, 2), \"R4\": (4.5, 2), \"R123\": (2.25, 2), \"R1234\": (3.75, 2), \"B\": (6, 2) } # Drawing steps steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Nested Circuit\", \"boxes\": [\"A\", \"R1\", \"R2\", \"R3\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"R4\"), (\"R3\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [], \"label_lines\": { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R2\"): \"R2\", (\"R1\", \"R3\"): \"R3\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"1/R23 = 1/R2 + 1/R3 \u2192 R23 = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: R2 || R3 \u2192 R23\", \"boxes\": [\"A\", \"R1\", \"R23\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R1\"), (\"R1\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"R123 = R1 + R23 = 10\u03a9 + 12\u03a9 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: R1 + R23 \u2192 R123\", \"boxes\": [\"A\", \"R123\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R123\"), (\"R123\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"A\", \"R123\"): \"R123\", (\"R123\", \"R4\"): \"R123\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"R1234 = R123 + R4 = 22\u03a9 + 40\u03a9 = 62.00\u03a9\" }, { \"title\": \"\u2705 Step 3: R123 + R4 \u2192 R1234\", \"boxes\": [\"A\", \"R1234\", \"B\"], \"lines\": [(\"A\", \"R1234\"), (\"R1234\", \"B\")], \"highlight\": [\"R1234\"], \"label_lines\": { (\"A\", \"R1234\"): \"R1234\" }, \"formula\": \"R_eq = 62.00\u03a9\" } ] # Highlight colors highlight_colors = { \"R23\": \"#F1948A\", \"R123\": \"#5DADE2\", \"R1234\": \"#BB8FCE\" } # Drawing function def draw_nested_step(step): fig, ax = plt.subplots(figsize=(10, 4.5)) ax.set_xlim(-1, 7) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) # Label resistors if \"label_lines\" in step and ((u, v) in step[\"label_lines\"] or (v, u) in step[\"label_lines\"]): key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"][key] if rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.4, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # \ud83d\udd01 Draw all steps for step in steps: draw_nested_step(step) # \u2705 Final Mixed Circuit Visualization with Edge Labels and Formulas import matplotlib.pyplot as plt import matplotlib.patches as patches # Ohm values resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R5\": 50, \"R23\": 1 / (1 / 20 + 1 / 30), # \u224812 \"R45\": 40 + 50, # 90 \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), # \u224822 \"R12345\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 + 50 # \u2248112 } # Positions of nodes positions = { \"B+\": (0, 2), \"R1\": (2, 0.5), \"R2\": (2, 3.5), \"R3\": (4, 3.5), \"R4\": (6, 2), \"R5\": (8, 2), \"R23\": (3, 3.5), \"R45\": (7, 2), \"R123\": (3, 2), \"R12345\": (4.5, 2), \"B-\": (10, 2) } # Simplification steps steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Circuit\", \"boxes\": [\"B+\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [], \"label_lines\": { (\"B+\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"R4\"): \"R4\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R23 = (R2 || R3) = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: Combine R2 || R3 \u2192 R23\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R45 = R4 + R5 = 40\u03a9 + 50\u03a9 = 90.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: Combine R4 + R5 \u2192 R45\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"B+\", \"R1\"), (\"R1\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R45\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R45\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R45\"): \"R4\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R123 = R1 + R23 = 10\u03a9 + 12\u03a9 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 3: Combine R1 + R23 \u2192 R123\", \"boxes\": [\"B+\", \"R123\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"B+\", \"R123\"): \"R123\", (\"R123\", \"R45\"): \"R123\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R12345 = R123 + R45 = 22\u03a9 + 90\u03a9 = 112.00\u03a9\" }, { \"title\": \"\u2705 Step 4: Final Equivalent Resistance\", \"boxes\": [\"B+\", \"R12345\", \"B-\"], \"lines\": [(\"B+\", \"R12345\"), (\"R12345\", \"B-\")], \"highlight\": [\"R12345\"], \"label_lines\": { (\"B+\", \"R12345\"): \"R12345\", (\"R12345\", \"B-\"): \"R12345\" }, \"formula\": \"R_eq = 112.00\u03a9\" } ] highlight_colors = { \"R23\": \"#FF6F61\", \"R45\": \"#76D7C4\", \"R123\": \"#85C1E9\", \"R12345\": \"#DDA0DD\" } # Drawing function def draw_step(step): fig, ax = plt.subplots(figsize=(11, 4.5)) ax.set_xlim(-1, 11) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") # Draw boxes for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") # Draw connections for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if \"label_lines\" in step: key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"].get(key) if rname and rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.5, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # \ud83d\uddbc\ufe0f Draw all simplification steps for step in steps: draw_step(step)","title":"\ud83d\udcd8 Phase 1: Understanding the Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#phase-1-understanding-the-concepts","text":"","title":"\ud83d\udcd8 Phase 1: Understanding the Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-rules","text":"Understanding how resistors combine is fundamental before translating circuits into graph models.","title":"\ud83d\udd0c Equivalent Resistance Rules"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"Resistors are in series if they are connected end-to-end with no branching. The equivalent resistance is the sum of the individual resistances: \\[ R_{\\text{eq(series)}} = R_1 + R_2 + R_3 + \\dots + R_n \\] Current through each resistor is the same. Voltage divides across resistors.","title":"\u2795 Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"Resistors are in parallel if both ends are connected to the same two nodes. The reciprocal of the equivalent resistance is the sum of reciprocals: \\[ \\frac{1}{R_{\\text{eq(parallel)}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\frac{1}{R_3} + \\dots + \\frac{1}{R_n} \\] Voltage across each resistor is the same. Current divides among the resistors.","title":"\ud83d\udd01 Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuit-to-graph-mapping","text":"To apply graph theory, we convert the electrical circuit into a mathematical graph: Nodes represent junctions in the circuit. Edges represent resistors , with the edge weight equal to the resistor\u2019s resistance (in ohms, \\(\\Omega\\) ).","title":"\ud83d\udcc8 Circuit-to-Graph Mapping"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts","text":"A resistor between two junctions is modeled as an undirected weighted edge between two nodes. The full circuit becomes a weighted undirected graph \\(G = (V, E)\\) , where: \\(V\\) is the set of junctions (vertices), \\(E\\) is the set of resistors (edges with weights).","title":"\ud83e\udde0 Key Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#benefits-of-graph-representation","text":"Structured and algorithmic simplification. Supports complex topologies and nested resistor configurations. Enables usage of algorithms from graph theory , such as traversal, cycle detection, and graph reduction.","title":"\u2705 Benefits of Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary","text":"By understanding how resistors combine and how to represent circuits as graphs, we lay the groundwork for designing an algorithm that can automate the process of finding equivalent resistance\u2014even in complex, nested networks.","title":"\ud83e\udded Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#phase-2-develop-the-algorithm-conceptual-level","text":"","title":"\u2705 Phase 2: Develop the Algorithm (Conceptual Level)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#objective","text":"We aim to design an algorithm that calculates the equivalent resistance of a complex circuit represented as a graph . The method must iteratively detect , simplify , and combine resistors until the graph reduces to a single equivalent resistance between two terminals.","title":"\ud83d\udd0d Objective"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts_1","text":"","title":"\ud83e\udde0 Key Concepts"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection-detection","text":"A series configuration occurs when: Two resistors share a common node of degree 2 . No branching occurs at this node. The equivalent resistance for series: $$ R_{\\text{eq}} = R_1 + R_2 $$","title":"\u2795 Series Connection Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection-detection","text":"A parallel configuration exists when: Multiple edges connect the same pair of nodes . The equivalent resistance for parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n} \\]","title":"\ud83d\udd01 Parallel Connection Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#iterative-graph-simplification","text":"We apply the following logic iteratively until the entire graph reduces to a single edge representing the total equivalent resistance: Detect series resistor pairs and combine. Detect parallel resistor groups and combine. Replace each group with its equivalent resistance . Repeat until no more simplifications are possible.","title":"\ud83d\udd01 Iterative Graph Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode-resistance-reduction-algorithm","text":"function compute_equivalent_resistance(graph G): while G has more than two nodes: for each node v in G: if degree(v) == 2: u, w = neighbors of v if edge(u, v) and edge(v, w) exist: R1 = weight of edge(u, v) R2 = weight of edge(v, w) replace with edge(u, w) with weight R1 + R2 remove node v and its incident edges for each pair of nodes (u, v): if multiple edges exist between u and v: Let R1, R2, ..., Rn be the weights of all edges(u, v) compute R_eq using: 1 / R_eq = 1 / R1 + 1 / R2 + ... + 1 / Rn replace all edges(u, v) with a single edge of weight R_eq return weight of final edge between terminals","title":"\ud83e\uddfe Pseudocode: Resistance Reduction Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-combinations","text":"","title":"\ud83d\udd04 Handling Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#_1","text":"Nested structures (e.g. series within parallel) are simplified recursively or by repeated iteration . The graph is dynamically updated: Merging two resistors may enable a new parallel pattern. Re-check after each merge.","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary_1","text":"This algorithm provides a robust and scalable method for calculating the equivalent resistance in arbitrary networks by: Modeling the circuit as a graph. Identifying structural patterns (series, parallel). Reducing them iteratively using physics-based rules. The approach is suitable for both manual analysis and automated implementations in tools like Python with networkx .","title":"\u2705 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#phase-3-work-on-examples","text":"","title":"\u2705 Phase 3: Work on Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#goal","text":"To demonstrate how the algorithm simplifies real-world circuit cases, we analyze three examples : Pure Series Resistors Pure Parallel Resistors Nested Configuration (Series and Parallel combined) Each example includes a description, circuit logic, and a step-by-step simplification.","title":"\ud83d\udd0d Goal"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series-resistors","text":"","title":"\ud83d\udd38 Example 1: Series Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#description","text":"Three resistors connected in series between two nodes A and D. Components : \\(R_1 = 5\\ \\Omega\\) \\(R_2 = 10\\ \\Omega\\) \\(R_3 = 15\\ \\Omega\\) Connection : A \u2014 R\u2081 \u2014 B \u2014 R\u2082 \u2014 C \u2014 R\u2083 \u2014 D","title":"\ud83e\udde9 Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-logic","text":"Series resistors are linearly connected : \\[ R_{\\text{eq}} = R_1 + R_2 + R_3 = 5 + 10 + 15 = 30\\ \\Omega \\] Algorithm detects each degree-2 node and collapses them iteratively: Combine A\u2013B and B\u2013C into A\u2013C Then combine A\u2013C and C\u2013D into A\u2013D","title":"\u2699\ufe0f Simplification Logic"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel-resistors","text":"","title":"\ud83d\udd38 Example 2: Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#description_1","text":"Two resistors connected in parallel between nodes A and B. Components : \\(R_1 = 10\\ \\Omega\\) \\(R_2 = 20\\ \\Omega\\) Connection : Path 1: A \u2192 R\u2081 \u2192 B Path 2: A \u2192 R\u2082 \u2192 B","title":"\ud83e\udde9 Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-logic_1","text":"Parallel resistors are connected across the same two nodes : \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\Rightarrow R_{\\text{eq}} = \\frac{20}{3} \\approx 6.67\\ \\Omega \\] Algorithm groups all edges between A and B, replaces them with the calculated equivalent resistance.","title":"\u2699\ufe0f Simplification Logic"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-configuration-series-parallel","text":"","title":"\ud83d\udd38 Example 3: Nested Configuration (Series + Parallel)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#description_2","text":"\\(R_1 = 5\\ \\Omega\\) (A \u2192 B) \\(R_2 = 10\\ \\Omega\\) (B \u2192 C) \\(R_3 = 20\\ \\Omega\\) (B \u2192 C) \u2014 parallel to R\u2082 \\(R_4 = 5\\ \\Omega\\) (C \u2192 D)","title":"\ud83e\udde9 Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#structure","text":"A \u2014 R\u2081 \u2014 B B \u2192 R\u2082 \u2192 C B \u2192 R\u2083 \u2192 C (in parallel with R\u2082) C \u2192 R\u2084 \u2192 D","title":"\ud83d\udee0 Structure:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-logic_2","text":"Parallel between B\u2013C : $$ \\frac{1}{R_{BC}} = \\frac{1}{10} + \\frac{1}{20} = \\frac{3}{20} \\Rightarrow R_{BC} = \\frac{20}{3} \\approx 6.67\\ \\Omega $$ New path becomes: A \u2014 R\u2081 \u2014 B \u2014 \\(R_{BC}\\) \u2014 C \u2014 R\u2084 \u2014 D Series total : \\[ R_{\\text{eq}} = R_1 + R_{BC} + R_4 = 5 + \\frac{20}{3} + 5 = \\frac{50}{3} \\approx 16.67\\ \\Omega \\] The algorithm reduces: Parallel group \u2192 replaces with \\(R_{BC}\\) Remaining series \u2192 collapsed step-by-step","title":"\u2699\ufe0f Simplification Logic"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visual","text":"","title":"Visual"},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary_2","text":"Type Formula Used Result Series \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) \\(30\\ \\Omega\\) Parallel \\(\\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i}\\) \\(6.67\\ \\Omega\\) Nested Series + Parallel combination \\(16.67\\ \\Omega\\) These examples validate how graph-based simplification can be used to iteratively reduce circuits of arbitrary complexity using consistent rules and clear patterns.","title":"\u2705 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#phase-4-analyze-the-algorithm","text":"","title":"\u2705 Phase 4: Analyze the Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-evaluation","text":"Understanding the computational efficiency of the graph-based resistance simplification algorithm is key for scaling to large networks.","title":"\ud83d\udcca Efficiency Evaluation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#number-of-steps","text":"Let \\(n\\) be the number of nodes , and \\(m\\) be the number of edges (resistors). In the worst case , the algorithm performs: \\(O(n)\\) passes for series simplifications. \\(O(m)\\) checks for parallel edge reductions.","title":"\ud83d\udd04 Number of Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#complexity-of-seriesparallel-detection","text":"","title":"\ud83d\udcc9 Complexity of Series/Parallel Detection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-detection","text":"For each node \\(v\\) : Check if \\(\\text{deg}(v) = 2\\) Cost: \\(O(n)\\) per pass If two neighbors \\(u\\) and \\(w\\) are connected to \\(v\\) : Combine \\(R_{uv}\\) and \\(R_{vw}\\) into \\(R_{uw}\\) Time per operation: \\(O(1)\\) Total complexity (series-only): \\(O(n^2)\\) in worst case due to repeated passes.","title":"\u2795 Series Detection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-detection","text":"For each unordered pair of nodes \\((u, v)\\) : Collect all edges between them: \\(O(m)\\) Reduce them using: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^{k} \\frac{1}{R_i} \\] Total complexity (parallel-only): \\(O(m^2)\\) worst case for densely connected graphs.","title":"\ud83d\udd01 Parallel Detection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#limitations","text":"","title":"\u26a0\ufe0f Limitations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#edge-cases-complex-cycles","text":"The current algorithm assumes: Graph is connected . No dependent sources or nonlinear elements (e.g., capacitors, inductors). Bridging nodes (nodes that are part of multiple paths) may delay detection of simplification patterns. Circuits with cycles that are not purely parallel can be harder to simplify without advanced techniques (e.g., mesh analysis).","title":"\ud83e\udde9 Edge Cases &amp; Complex Cycles"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visualization","text":"","title":"\ud83d\udcc8 Visualization"},{"location":"1%20Physics/5%20Circuits/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#summary_3","text":"Aspect Summary Series Detection Fast per step, repeated passes required ( \\(O(n^2)\\) worst case) Parallel Detection Simple but costly in dense graphs ( \\(O(m^2)\\) worst case) Limitations Cannot directly solve meshes, bridges, or nonlinear elements Improvements DFS, union-find, real-time animation, and better data structures This phase ensures the algorithm isn't just correct , but also efficient , scalable , and educationally valuable in practice.","title":"\u2705 Summary"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-codes","text":"import matplotlib.pyplot as plt import matplotlib.patches as patches import matplotlib.animation as animation # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R5\": 50, \"R23\": 1 / (1 / 20 + 1 / 30), \"R45\": 40 + 50, \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), \"R12345\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 + 50 } positions = { \"B+\": (0, 2), \"R1\": (2, 0.5), \"R2\": (2, 3.5), \"R3\": (4, 3.5), \"R4\": (6, 2), \"R5\": (8, 2), \"R23\": (3, 3.5), \"R45\": (7, 2), \"R123\": (3, 2), \"R12345\": (4.5, 2), \"B-\": (10, 2) } steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Circuit\", \"boxes\": [\"B+\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [], \"label_lines\": { (\"B+\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"R4\"): \"R4\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R23 = (R2 || R3) = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: Combine R2 || R3 \u2192 R23\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R45 = R4 + R5 = 90.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: Combine R4 + R5 \u2192 R45\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"B+\", \"R1\"), (\"R1\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R45\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R45\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R45\"): \"R4\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R123 = R1 + R23 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 3: Combine R1 + R23 \u2192 R123\", \"boxes\": [\"B+\", \"R123\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"B+\", \"R123\"): \"R123\", (\"R123\", \"R45\"): \"R123\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R12345 = R123 + R45 = 112.00\u03a9\" }, { \"title\": \"\u2705 Final Result: R12345\", \"boxes\": [\"B+\", \"R12345\", \"B-\"], \"lines\": [(\"B+\", \"R12345\"), (\"R12345\", \"B-\")], \"highlight\": [\"R12345\"], \"label_lines\": { (\"B+\", \"R12345\"): \"R12345\", (\"R12345\", \"B-\"): \"R12345\" }, \"formula\": \"R_eq = 112.00\u03a9\" } ] highlight_colors = { \"R23\": \"#FF6F61\", \"R45\": \"#76D7C4\", \"R123\": \"#85C1E9\", \"R12345\": \"#DDA0DD\" } # Draw frame for animation def draw_frame(i): step = steps[i] ax.clear() ax.set_xlim(-1, 11) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if \"label_lines\" in step: key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"].get(key) if rname and rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.5, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') # Create the animation fig, ax = plt.subplots(figsize=(11, 4.5)) ani = animation.FuncAnimation(fig, draw_frame, frames=len(steps), interval=1500, repeat=True) # Save to GIF gif_path = \"/content/circuit_simplification.gif\" ani.save(gif_path, writer=\"pillow\", fps=1) from IPython.display import Image Image(filename=gif_path) # \u2705 Final Clean Circuit Diagrams with Small Fonts and Beautiful Layout import matplotlib.pyplot as plt import matplotlib.patches as patches # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"Req_series\": 10 + 20 + 30, \"Req_parallel\": 1 / (1 / 10 + 1 / 20) } # Layouts with wider spacing positions_series = { \"A\": (0, 2), \"R1\": (2, 2), \"R2\": (4, 2), \"R3\": (6, 2), \"Req\": (4, 2), \"B\": (8, 2) } positions_parallel = { \"A\": (0, 2), \"R1\": (2, 3.2), \"R2\": (2, 0.8), \"Req\": (2, 2), \"B\": (4, 2) } highlight_colors = {\"Req\": \"#BB8FCE\"} line_labels_series = { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"B\"): \"R3\" } line_labels_parallel = { (\"A\", \"R1\"): \"R1\", (\"R1\", \"B\"): \"R1\", (\"A\", \"R2\"): \"R2\", (\"R2\", \"B\"): \"R2\" } # Drawing function def draw_valued_circuit(title, boxes, lines, highlight=[], positions=None, line_labels=None, note=\"\", formula=\"\"): fig, ax = plt.subplots(figsize=(11, 5)) ax.set_xlim(-1, 9) ax.set_ylim(-0.5, 5.5) ax.axis(\"off\") ax.set_title(title, fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") # Boxes for box in boxes: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in highlight else \"#F2F4F4\" rect = patches.FancyBboxPatch( (x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=1.8 ) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight='bold', color=\"#34495E\") # Arrows + edge labels for u, v in lines: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if line_labels: key = (u, v) if (u, v) in line_labels else (v, u) if key in line_labels: rname = line_labels[key] if rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" offset = 0.25 if abs(y2 - y1) < 0.1 else 0.15 ax.text(mx, my + offset, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.2, note, fontsize=9, style='italic', color='gray') ax.text(0, -0.45, formula, fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # Values R1, R2, R3 = resistor_values[\"R1\"], resistor_values[\"R2\"], resistor_values[\"R3\"] R_eq_series = resistor_values[\"Req_series\"] R_eq_parallel = resistor_values[\"Req_parallel\"] # Series Step 1 draw_valued_circuit( \"\ud83d\udd30 Series Connection \u2013 Step 1\", [\"A\", \"R1\", \"R2\", \"R3\", \"B\"], [(\"A\", \"R1\"), (\"R1\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"B\")], positions=positions_series, line_labels=line_labels_series, note=\"Three resistors connected in series.\", formula=f\"R_eq = {R1}\u03a9 + {R2}\u03a9 + {R3}\u03a9 = {R_eq_series:.2f}\u03a9\" ) # Series Step 2 draw_valued_circuit( \"\u2705 Series Connection \u2013 Step 2: Simplified Req\", [\"A\", \"Req\", \"B\"], [(\"A\", \"Req\"), (\"Req\", \"B\")], highlight=[\"Req\"], positions=positions_series, note=\"Replaced with equivalent Req.\", formula=f\"R_eq = {R_eq_series:.2f}\u03a9\" ) # Parallel Step 1 draw_valued_circuit( \"\ud83d\udd30 Parallel Connection \u2013 Step 1\", [\"A\", \"R1\", \"R2\", \"B\"], [(\"A\", \"R1\"), (\"R1\", \"B\"), (\"A\", \"R2\"), (\"R2\", \"B\")], positions=positions_parallel, line_labels=line_labels_parallel, note=\"Two resistors connected in parallel.\", formula=f\"1/R_eq = 1/{R1} + 1/{R2} \u2192 R_eq = {R_eq_parallel:.2f}\u03a9\" ) # Parallel Step 2 draw_valued_circuit( \"\u2705 Parallel Connection \u2013 Step 2: Simplified Req\", [\"A\", \"Req\", \"B\"], [(\"A\", \"Req\"), (\"Req\", \"B\")], highlight=[\"Req\"], positions=positions_parallel, note=\"Replaced with equivalent Req.\", formula=f\"R_eq = {R_eq_parallel:.2f}\u03a9\" ) # \u2705 Final Nested Circuit Simplification with R = xx\u03a9 Labels (Colab-ready) import matplotlib.pyplot as plt import matplotlib.patches as patches # Resistor values (Ohms) resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R23\": 1 / (1 / 20 + 1 / 30), \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), \"R1234\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 } # Node positions positions = { \"A\": (0, 2), \"R1\": (1.5, 2), \"R2\": (3, 3.5), \"R3\": (3, 0.5), \"R23\": (3, 2), \"R4\": (4.5, 2), \"R123\": (2.25, 2), \"R1234\": (3.75, 2), \"B\": (6, 2) } # Drawing steps steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Nested Circuit\", \"boxes\": [\"A\", \"R1\", \"R2\", \"R3\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R1\"), (\"R1\", \"R2\"), (\"R1\", \"R3\"), (\"R2\", \"R4\"), (\"R3\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [], \"label_lines\": { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R2\"): \"R2\", (\"R1\", \"R3\"): \"R3\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"1/R23 = 1/R2 + 1/R3 \u2192 R23 = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: R2 || R3 \u2192 R23\", \"boxes\": [\"A\", \"R1\", \"R23\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R1\"), (\"R1\", \"R23\"), (\"R23\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"A\", \"R1\"): \"R1\", (\"R1\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"R123 = R1 + R23 = 10\u03a9 + 12\u03a9 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: R1 + R23 \u2192 R123\", \"boxes\": [\"A\", \"R123\", \"R4\", \"B\"], \"lines\": [(\"A\", \"R123\"), (\"R123\", \"R4\"), (\"R4\", \"B\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"A\", \"R123\"): \"R123\", (\"R123\", \"R4\"): \"R123\", (\"R4\", \"B\"): \"R4\" }, \"formula\": \"R1234 = R123 + R4 = 22\u03a9 + 40\u03a9 = 62.00\u03a9\" }, { \"title\": \"\u2705 Step 3: R123 + R4 \u2192 R1234\", \"boxes\": [\"A\", \"R1234\", \"B\"], \"lines\": [(\"A\", \"R1234\"), (\"R1234\", \"B\")], \"highlight\": [\"R1234\"], \"label_lines\": { (\"A\", \"R1234\"): \"R1234\" }, \"formula\": \"R_eq = 62.00\u03a9\" } ] # Highlight colors highlight_colors = { \"R23\": \"#F1948A\", \"R123\": \"#5DADE2\", \"R1234\": \"#BB8FCE\" } # Drawing function def draw_nested_step(step): fig, ax = plt.subplots(figsize=(10, 4.5)) ax.set_xlim(-1, 7) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) # Label resistors if \"label_lines\" in step and ((u, v) in step[\"label_lines\"] or (v, u) in step[\"label_lines\"]): key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"][key] if rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.4, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # \ud83d\udd01 Draw all steps for step in steps: draw_nested_step(step) # \u2705 Final Mixed Circuit Visualization with Edge Labels and Formulas import matplotlib.pyplot as plt import matplotlib.patches as patches # Ohm values resistor_values = { \"R1\": 10, \"R2\": 20, \"R3\": 30, \"R4\": 40, \"R5\": 50, \"R23\": 1 / (1 / 20 + 1 / 30), # \u224812 \"R45\": 40 + 50, # 90 \"R123\": 10 + (1 / (1 / 20 + 1 / 30)), # \u224822 \"R12345\": 10 + (1 / (1 / 20 + 1 / 30)) + 40 + 50 # \u2248112 } # Positions of nodes positions = { \"B+\": (0, 2), \"R1\": (2, 0.5), \"R2\": (2, 3.5), \"R3\": (4, 3.5), \"R4\": (6, 2), \"R5\": (8, 2), \"R23\": (3, 3.5), \"R45\": (7, 2), \"R123\": (3, 2), \"R12345\": (4.5, 2), \"B-\": (10, 2) } # Simplification steps steps = [ { \"title\": \"\ud83d\udd30 Step 0: Initial Circuit\", \"boxes\": [\"B+\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R2\"), (\"R2\", \"R3\"), (\"R3\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [], \"label_lines\": { (\"B+\", \"R2\"): \"R2\", (\"R2\", \"R3\"): \"R3\", (\"R3\", \"R4\"): \"R4\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R23 = (R2 || R3) = 12.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 1: Combine R2 || R3 \u2192 R23\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R4\", \"R5\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R4\"), (\"B+\", \"R1\"), (\"R1\", \"R4\"), (\"R4\", \"R5\"), (\"R5\", \"B-\")], \"highlight\": [\"R23\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R4\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R4\"): \"R4\", (\"R4\", \"R5\"): \"R5\", (\"R5\", \"B-\"): \"R5\" }, \"formula\": \"R45 = R4 + R5 = 40\u03a9 + 50\u03a9 = 90.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 2: Combine R4 + R5 \u2192 R45\", \"boxes\": [\"B+\", \"R1\", \"R23\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R23\"), (\"R23\", \"R45\"), (\"B+\", \"R1\"), (\"R1\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R45\"], \"label_lines\": { (\"B+\", \"R23\"): \"R23\", (\"R23\", \"R45\"): \"R23\", (\"B+\", \"R1\"): \"R1\", (\"R1\", \"R45\"): \"R4\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R123 = R1 + R23 = 10\u03a9 + 12\u03a9 = 22.00\u03a9\" }, { \"title\": \"\ud83d\udd01 Step 3: Combine R1 + R23 \u2192 R123\", \"boxes\": [\"B+\", \"R123\", \"R45\", \"B-\"], \"lines\": [(\"B+\", \"R123\"), (\"R123\", \"R45\"), (\"R45\", \"B-\")], \"highlight\": [\"R123\"], \"label_lines\": { (\"B+\", \"R123\"): \"R123\", (\"R123\", \"R45\"): \"R123\", (\"R45\", \"B-\"): \"R45\" }, \"formula\": \"R12345 = R123 + R45 = 22\u03a9 + 90\u03a9 = 112.00\u03a9\" }, { \"title\": \"\u2705 Step 4: Final Equivalent Resistance\", \"boxes\": [\"B+\", \"R12345\", \"B-\"], \"lines\": [(\"B+\", \"R12345\"), (\"R12345\", \"B-\")], \"highlight\": [\"R12345\"], \"label_lines\": { (\"B+\", \"R12345\"): \"R12345\", (\"R12345\", \"B-\"): \"R12345\" }, \"formula\": \"R_eq = 112.00\u03a9\" } ] highlight_colors = { \"R23\": \"#FF6F61\", \"R45\": \"#76D7C4\", \"R123\": \"#85C1E9\", \"R12345\": \"#DDA0DD\" } # Drawing function def draw_step(step): fig, ax = plt.subplots(figsize=(11, 4.5)) ax.set_xlim(-1, 11) ax.set_ylim(-1, 5) ax.axis(\"off\") ax.set_title(step[\"title\"], fontsize=13, pad=10, weight='bold', color=\"#2C3E50\") # Draw boxes for box in step[\"boxes\"]: x, y = positions[box] color = highlight_colors.get(box, \"#D6DBDF\") if box in step[\"highlight\"] else \"#F2F4F4\" rect = patches.FancyBboxPatch((x - 0.3, y - 0.3), 0.6, 0.6, boxstyle=\"round,pad=0.1\", edgecolor=\"#2C3E50\", facecolor=color, linewidth=2) ax.add_patch(rect) ax.text(x, y, box, ha=\"center\", va=\"center\", fontsize=9, weight=\"bold\", color=\"#34495E\") # Draw connections for u, v in step[\"lines\"]: x1, y1 = positions[u] x2, y2 = positions[v] mx, my = (x1 + x2) / 2, (y1 + y2) / 2 ax.annotate(\"\", xy=(x2, y2), xytext=(x1, y1), arrowprops=dict(arrowstyle=\"->\", lw=2, color=\"#566573\")) if \"label_lines\" in step: key = (u, v) if (u, v) in step[\"label_lines\"] else (v, u) rname = step[\"label_lines\"].get(key) if rname and rname in resistor_values: rlabel = f\"R = {resistor_values[rname]:.2f}\u03a9\" ax.text(mx, my + 0.25, rlabel, ha=\"center\", va=\"center\", fontsize=9, color=\"#7D3C98\", weight='bold') ax.text(0, -0.5, step[\"formula\"], fontsize=10, weight='bold', color='#1F618D') plt.tight_layout() plt.show() # \ud83d\uddbc\ufe0f Draw all simplification steps for step in steps: draw_step(step)","title":"Python Codes"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcca Simulating Sampling Distributions \ud83c\udfaf Objective To demonstrate the Central Limit Theorem (CLT), we begin by generating large populations from various distributions: Uniform Distribution Exponential Distribution Binomial Distribution Each dataset will represent a \"population\", from which we will later draw repeated random samples to study the behavior of their means. \ud83d\udd22 Step 1: Generate Populations Let: - \\(N = 100000\\) be the size of each simulated population. We will define each population as follows: Uniform Distribution : \\[X \\sim \\text{Uniform}(a=0, b=1)\\] Exponential Distribution : \\[X \\sim \\text{Exponential}(\\lambda=1)\\] Binomial Distribution : \\[X \\sim \\text{Binomial}(n=10, p=0.5)\\] \ud83e\uddea Python Code/ Visual import numpy as np import matplotlib.pyplot as plt # Set seed for reproducibility np.random.seed(42) # Population size N = 100_000 # --- Generate Populations --- # 1. Uniform Distribution: U(0, 1) population_uniform = np.random.uniform(low=0, high=1, size=N) # 2. Exponential Distribution: Exp(\u03bb=1) population_exponential = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution: Binomial(n=10, p=0.5) population_binomial = np.random.binomial(n=10, p=0.5, size=N) # --- Plot Histograms --- fig, axs = plt.subplots(1, 3, figsize=(18, 4)) # Uniform axs[0].hist(population_uniform, bins=50, color='skyblue', edgecolor='black') axs[0].set_title(\"Uniform(0,1) Distribution\") axs[0].set_xlabel(\"Value\") axs[0].set_ylabel(\"Frequency\") # Exponential axs[1].hist(population_exponential, bins=50, color='salmon', edgecolor='black') axs[1].set_title(\"Exponential(\u03bb=1) Distribution\") axs[1].set_xlabel(\"Value\") axs[1].set_ylabel(\"Frequency\") # Binomial axs[2].hist(population_binomial, bins=range(0,12), color='lightgreen', edgecolor='black', align='left') axs[2].set_title(\"Binomial(n=10, p=0.5) Distribution\") axs[2].set_xlabel(\"Value\") axs[2].set_ylabel(\"Frequency\") plt.tight_layout() plt.show() \ud83e\udde0 Observations The Uniform distribution is symmetric and flat. The Exponential distribution is positively skewed, with a long tail. The Binomial distribution appears discrete and approximately symmetric for \\(p=0.5\\) , \\(n=10\\) . These variations in shape are crucial because, according to the Central Limit Theorem , the sampling distribution of the sample mean should approach a normal distribution , even if the underlying population is not normal. \ud83d\udcc8 Sampling and Visualization \ud83c\udfaf Objective Now that we've simulated our population distributions, we move to the core demonstration of the Central Limit Theorem (CLT) by: Drawing repeated random samples of various sizes. Calculating sample means. Building and visualizing sampling distributions. Observing how they approach normality. \ud83d\udd01 Step-by-Step Procedure 1. Select Sample Sizes We will use the following sample sizes: \\(n = 5\\) \\(n = 10\\) \\(n = 30\\) \\(n = 50\\) 2. Sampling Process Let: - \\(R = 1000\\) be the number of repetitions (samples drawn per sample size). For each sample size \\(n\\) , and each population: Draw \\(R\\) samples of size \\(n\\) . Compute the sample mean \\(\\bar{X}\\) for each. Store these means to analyze their distribution. \ud83e\uddea Python Code import numpy as np import matplotlib.pyplot as plt # Parameters sample_sizes = [5, 10, 30, 50] repeats = 1000 # Store results sampling_results = { \"uniform\": {}, \"exponential\": {}, \"binomial\": {} } # Sampling function def simulate_sampling_distribution(population, name): for n in sample_sizes: means = [] for _ in range(repeats): sample = np.random.choice(population, size=n, replace=False) sample_mean = np.mean(sample) means.append(sample_mean) sampling_results[name][n] = means # Run simulations simulate_sampling_distribution(population_uniform, \"uniform\") simulate_sampling_distribution(population_exponential, \"exponential\") simulate_sampling_distribution(population_binomial, \"binomial\") \ud83d\udcca Visualization We will now plot the sampling distribution of the mean for each combination of: Distribution: Uniform, Exponential, Binomial Sample Size: \\(n = 5, 10, 30, 50\\) import matplotlib.pyplot as plt import seaborn as sns # Seaborn style for aesthetics sns.set(style=\"whitegrid\") # Plot sampling distributions fig, axs = plt.subplots(3, 4, figsize=(22, 12)) distributions = [\"uniform\", \"exponential\", \"binomial\"] titles = [\"Uniform\", \"Exponential\", \"Binomial\"] colors = sns.color_palette(\"Set2\", 4) for i, dist in enumerate(distributions): for j, n in enumerate(sample_sizes): axs[i][j].hist( sampling_results[dist][n], bins=30, color=colors[j], edgecolor='black', alpha=0.85 ) axs[i][j].set_title(f\"{titles[i]} Dist - Sample Size n={n}\", fontsize=14, fontweight='bold') axs[i][j].set_xlabel(\"Sample Mean\", fontsize=12) axs[i][j].set_ylabel(\"Frequency\", fontsize=12) # Add an overall title fig.suptitle(\"Sampling Distributions of the Mean by Population and Sample Size\", fontsize=18, fontweight='bold') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() \ud83d\udcda Theoretical Background According to the Central Limit Theorem , for a sufficiently large sample size \\(n\\) : The distribution of the sample mean \\(\\bar{X}\\) tends toward a normal distribution, regardless of the shape of the population distribution, provided the variance \\(\\sigma^2\\) is finite. Mathematically: If \\(X_1, X_2, \\dots, X_n\\) are i.i.d. with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i \\quad \\text{converges in distribution to} \\quad \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\] \ud83e\udde0 Observations As \\(n\\) increases: The histograms of sample means become more bell-shaped . This occurs even when the original distribution is skewed , e.g., Exponential. The spread of the sampling distribution decreases with larger \\(n\\) , consistent with: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\] \ud83e\uddea Parameter Exploration In this section, we explore how different parameters influence the behavior of sampling distributions under the Central Limit Theorem (CLT). \ud83d\udd0d 1. Effect of the Original Distribution Shape Key Insight : The more skewed or non-normal the original population is, the slower the convergence to a normal distribution. Visual Observation : Sampling distributions from the Exponential distribution (heavily skewed) take longer to appear normal. Sampling distributions from Uniform or Binomial (p \u2248 0.5) appear bell-shaped even at moderate sample sizes. CLT Implication : For highly non-normal populations, a larger \\(n\\) is needed for the sampling distribution of the mean to approximate normality. \ud83d\udcc8 2. Influence of Sample Size on Normality Let: \\(X_1, X_2, \\dots, X_n\\) be i.i.d. random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i\\) Then, by the Central Limit Theorem : \\[ \\bar{X} \\xrightarrow{d} \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\quad \\text{as} \\quad n \\to \\infty \\] Observation : As \\(n\\) increases, the shape of the sampling distribution becomes more symmetric and bell-shaped. The convergence is faster when the population is closer to normal. \ud83d\udcca 3. Role of Population Variance in Spread Standard Error (SE) of the sample mean is: \\[ \\text{SE}_{\\bar{X}} = \\frac{\\sigma}{\\sqrt{n}} \\] Implications : Populations with larger variance \\(\\sigma^2\\) yield wider sampling distributions . As sample size \\(n\\) increases, SE decreases, causing the sampling distribution to narrow . \ud83d\udcdd Summary Table Factor Effect on Sampling Distribution Shape of Original Distribution Skewed \u2192 slower normal convergence Sample Size ( \\(n\\) ) Larger \\(n\\) \u2192 faster convergence, tighter distribution Population Variance ( \\(\\sigma^2\\) ) Higher variance \u2192 wider spread in sample means \ud83d\udcda Interpretation These effects are critical when: - Designing experiments : Choose a sufficiently large \\(n\\) based on the distribution shape. - Estimating parameters : Know that estimates are more precise when variance is low or \\(n\\) is high. - Communicating uncertainty : Larger spreads in sampling distributions indicate higher estimation uncertainty. \ud83c\udf0d Practical Applications of the Central Limit Theorem The Central Limit Theorem (CLT) plays a foundational role across many fields by enabling the use of normal approximation when analyzing sample means \u2014 even when the original data is not normally distributed. \ud83d\udcd0 1. Estimating Population Parameters When taking a sample of size \\(n\\) from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) The sample mean \\(\\bar{X}\\) is used to estimate the population mean: \\[ \\mathbb{E}[\\bar{X}] = \\mu \\] Due to CLT: \\[ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This allows us to: Construct confidence intervals \\[ \\bar{X} \\pm z_{\\alpha/2} \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] Perform hypothesis testing using \\(z\\) -scores. \u2705 Use Case : Estimating the average height, income, or lifespan from survey data. \ud83c\udfed 2. Quality Control in Manufacturing Suppose a factory produces parts with a target dimension (e.g., length = 5cm). Random samples of \\(n\\) units are taken periodically. If the sample mean deviates significantly from the target, corrective action is taken. Using CLT, the distribution of the sample mean allows creation of control charts : Define control limits at: \\[ \\mu \\pm 3 \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] This detects issues like: Machine misalignment Material flaws Process drift \u2705 Use Case : Monitoring packaging weight, fluid volumes, or part dimensions. \ud83d\udcb9 3. Financial Outcome Predictions Financial metrics (e.g., returns, costs, profits) often come from aggregates of many random variables. Thanks to CLT: The total return or average risk from a portfolio of assets approximates normality. Enables use of tools like: Value-at-Risk (VaR) Monte Carlo simulations Example: \\[ \\text{Portfolio Return} = \\frac{1}{n} \\sum_{i=1}^n R_i \\approx \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] \u2705 Use Case : Estimating probable gains/losses for investments over time. \ud83e\udde0 Conclusion The Central Limit Theorem enables: - Reliable estimation even from non-normal populations - Inferential power in small to medium sample sizes - Foundation for statistical decision-making in science, industry, and finance \ud83d\udccc It's one of the most powerful bridges between theory and practice in statistics.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulating-sampling-distributions","text":"","title":"\ud83d\udcca Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"To demonstrate the Central Limit Theorem (CLT), we begin by generating large populations from various distributions: Uniform Distribution Exponential Distribution Binomial Distribution Each dataset will represent a \"population\", from which we will later draw repeated random samples to study the behavior of their means.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-1-generate-populations","text":"Let: - \\(N = 100000\\) be the size of each simulated population. We will define each population as follows: Uniform Distribution : \\[X \\sim \\text{Uniform}(a=0, b=1)\\] Exponential Distribution : \\[X \\sim \\text{Exponential}(\\lambda=1)\\] Binomial Distribution : \\[X \\sim \\text{Binomial}(n=10, p=0.5)\\]","title":"\ud83d\udd22 Step 1: Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-visual","text":"import numpy as np import matplotlib.pyplot as plt # Set seed for reproducibility np.random.seed(42) # Population size N = 100_000 # --- Generate Populations --- # 1. Uniform Distribution: U(0, 1) population_uniform = np.random.uniform(low=0, high=1, size=N) # 2. Exponential Distribution: Exp(\u03bb=1) population_exponential = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution: Binomial(n=10, p=0.5) population_binomial = np.random.binomial(n=10, p=0.5, size=N) # --- Plot Histograms --- fig, axs = plt.subplots(1, 3, figsize=(18, 4)) # Uniform axs[0].hist(population_uniform, bins=50, color='skyblue', edgecolor='black') axs[0].set_title(\"Uniform(0,1) Distribution\") axs[0].set_xlabel(\"Value\") axs[0].set_ylabel(\"Frequency\") # Exponential axs[1].hist(population_exponential, bins=50, color='salmon', edgecolor='black') axs[1].set_title(\"Exponential(\u03bb=1) Distribution\") axs[1].set_xlabel(\"Value\") axs[1].set_ylabel(\"Frequency\") # Binomial axs[2].hist(population_binomial, bins=range(0,12), color='lightgreen', edgecolor='black', align='left') axs[2].set_title(\"Binomial(n=10, p=0.5) Distribution\") axs[2].set_xlabel(\"Value\") axs[2].set_ylabel(\"Frequency\") plt.tight_layout() plt.show()","title":"\ud83e\uddea Python Code/ Visual"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations","text":"The Uniform distribution is symmetric and flat. The Exponential distribution is positively skewed, with a long tail. The Binomial distribution appears discrete and approximately symmetric for \\(p=0.5\\) , \\(n=10\\) . These variations in shape are crucial because, according to the Central Limit Theorem , the sampling distribution of the sample mean should approach a normal distribution , even if the underlying population is not normal.","title":"\ud83e\udde0 Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-and-visualization","text":"","title":"\ud83d\udcc8 Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective_1","text":"Now that we've simulated our population distributions, we move to the core demonstration of the Central Limit Theorem (CLT) by: Drawing repeated random samples of various sizes. Calculating sample means. Building and visualizing sampling distributions. Observing how they approach normality.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-by-step-procedure","text":"","title":"\ud83d\udd01 Step-by-Step Procedure"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-select-sample-sizes","text":"We will use the following sample sizes: \\(n = 5\\) \\(n = 10\\) \\(n = 30\\) \\(n = 50\\)","title":"1. Select Sample Sizes"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-process","text":"Let: - \\(R = 1000\\) be the number of repetitions (samples drawn per sample size). For each sample size \\(n\\) , and each population: Draw \\(R\\) samples of size \\(n\\) . Compute the sample mean \\(\\bar{X}\\) for each. Store these means to analyze their distribution.","title":"2. Sampling Process"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters sample_sizes = [5, 10, 30, 50] repeats = 1000 # Store results sampling_results = { \"uniform\": {}, \"exponential\": {}, \"binomial\": {} } # Sampling function def simulate_sampling_distribution(population, name): for n in sample_sizes: means = [] for _ in range(repeats): sample = np.random.choice(population, size=n, replace=False) sample_mean = np.mean(sample) means.append(sample_mean) sampling_results[name][n] = means # Run simulations simulate_sampling_distribution(population_uniform, \"uniform\") simulate_sampling_distribution(population_exponential, \"exponential\") simulate_sampling_distribution(population_binomial, \"binomial\")","title":"\ud83e\uddea Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization","text":"We will now plot the sampling distribution of the mean for each combination of: Distribution: Uniform, Exponential, Binomial Sample Size: \\(n = 5, 10, 30, 50\\) import matplotlib.pyplot as plt import seaborn as sns # Seaborn style for aesthetics sns.set(style=\"whitegrid\") # Plot sampling distributions fig, axs = plt.subplots(3, 4, figsize=(22, 12)) distributions = [\"uniform\", \"exponential\", \"binomial\"] titles = [\"Uniform\", \"Exponential\", \"Binomial\"] colors = sns.color_palette(\"Set2\", 4) for i, dist in enumerate(distributions): for j, n in enumerate(sample_sizes): axs[i][j].hist( sampling_results[dist][n], bins=30, color=colors[j], edgecolor='black', alpha=0.85 ) axs[i][j].set_title(f\"{titles[i]} Dist - Sample Size n={n}\", fontsize=14, fontweight='bold') axs[i][j].set_xlabel(\"Sample Mean\", fontsize=12) axs[i][j].set_ylabel(\"Frequency\", fontsize=12) # Add an overall title fig.suptitle(\"Sampling Distributions of the Mean by Population and Sample Size\", fontsize=18, fontweight='bold') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"\ud83d\udcca Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#theoretical-background","text":"According to the Central Limit Theorem , for a sufficiently large sample size \\(n\\) : The distribution of the sample mean \\(\\bar{X}\\) tends toward a normal distribution, regardless of the shape of the population distribution, provided the variance \\(\\sigma^2\\) is finite. Mathematically: If \\(X_1, X_2, \\dots, X_n\\) are i.i.d. with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i \\quad \\text{converges in distribution to} \\quad \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\]","title":"\ud83d\udcda Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations_1","text":"As \\(n\\) increases: The histograms of sample means become more bell-shaped . This occurs even when the original distribution is skewed , e.g., Exponential. The spread of the sampling distribution decreases with larger \\(n\\) , consistent with: \\[ \\text{Standard Error} = \\frac{\\sigma}{\\sqrt{n}} \\]","title":"\ud83e\udde0 Observations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration","text":"In this section, we explore how different parameters influence the behavior of sampling distributions under the Central Limit Theorem (CLT).","title":"\ud83e\uddea Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-effect-of-the-original-distribution-shape","text":"Key Insight : The more skewed or non-normal the original population is, the slower the convergence to a normal distribution. Visual Observation : Sampling distributions from the Exponential distribution (heavily skewed) take longer to appear normal. Sampling distributions from Uniform or Binomial (p \u2248 0.5) appear bell-shaped even at moderate sample sizes. CLT Implication : For highly non-normal populations, a larger \\(n\\) is needed for the sampling distribution of the mean to approximate normality.","title":"\ud83d\udd0d 1. Effect of the Original Distribution Shape"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-influence-of-sample-size-on-normality","text":"Let: \\(X_1, X_2, \\dots, X_n\\) be i.i.d. random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i\\) Then, by the Central Limit Theorem : \\[ \\bar{X} \\xrightarrow{d} \\mathcal{N}(\\mu, \\frac{\\sigma^2}{n}) \\quad \\text{as} \\quad n \\to \\infty \\] Observation : As \\(n\\) increases, the shape of the sampling distribution becomes more symmetric and bell-shaped. The convergence is faster when the population is closer to normal.","title":"\ud83d\udcc8 2. Influence of Sample Size on Normality"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-role-of-population-variance-in-spread","text":"Standard Error (SE) of the sample mean is: \\[ \\text{SE}_{\\bar{X}} = \\frac{\\sigma}{\\sqrt{n}} \\] Implications : Populations with larger variance \\(\\sigma^2\\) yield wider sampling distributions . As sample size \\(n\\) increases, SE decreases, causing the sampling distribution to narrow .","title":"\ud83d\udcca 3. Role of Population Variance in Spread"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary-table","text":"Factor Effect on Sampling Distribution Shape of Original Distribution Skewed \u2192 slower normal convergence Sample Size ( \\(n\\) ) Larger \\(n\\) \u2192 faster convergence, tighter distribution Population Variance ( \\(\\sigma^2\\) ) Higher variance \u2192 wider spread in sample means","title":"\ud83d\udcdd Summary Table"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interpretation","text":"These effects are critical when: - Designing experiments : Choose a sufficiently large \\(n\\) based on the distribution shape. - Estimating parameters : Know that estimates are more precise when variance is low or \\(n\\) is high. - Communicating uncertainty : Larger spreads in sampling distributions indicate higher estimation uncertainty.","title":"\ud83d\udcda Interpretation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications-of-the-central-limit-theorem","text":"The Central Limit Theorem (CLT) plays a foundational role across many fields by enabling the use of normal approximation when analyzing sample means \u2014 even when the original data is not normally distributed.","title":"\ud83c\udf0d Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-estimating-population-parameters","text":"When taking a sample of size \\(n\\) from a population with: Mean \\(\\mu\\) Standard deviation \\(\\sigma\\) The sample mean \\(\\bar{X}\\) is used to estimate the population mean: \\[ \\mathbb{E}[\\bar{X}] = \\mu \\] Due to CLT: \\[ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] This allows us to: Construct confidence intervals \\[ \\bar{X} \\pm z_{\\alpha/2} \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] Perform hypothesis testing using \\(z\\) -scores. \u2705 Use Case : Estimating the average height, income, or lifespan from survey data.","title":"\ud83d\udcd0 1. Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-quality-control-in-manufacturing","text":"Suppose a factory produces parts with a target dimension (e.g., length = 5cm). Random samples of \\(n\\) units are taken periodically. If the sample mean deviates significantly from the target, corrective action is taken. Using CLT, the distribution of the sample mean allows creation of control charts : Define control limits at: \\[ \\mu \\pm 3 \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] This detects issues like: Machine misalignment Material flaws Process drift \u2705 Use Case : Monitoring packaging weight, fluid volumes, or part dimensions.","title":"\ud83c\udfed 2. Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-financial-outcome-predictions","text":"Financial metrics (e.g., returns, costs, profits) often come from aggregates of many random variables. Thanks to CLT: The total return or average risk from a portfolio of assets approximates normality. Enables use of tools like: Value-at-Risk (VaR) Monte Carlo simulations Example: \\[ \\text{Portfolio Return} = \\frac{1}{n} \\sum_{i=1}^n R_i \\approx \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\] \u2705 Use Case : Estimating probable gains/losses for investments over time.","title":"\ud83d\udcb9 3. Financial Outcome Predictions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem enables: - Reliable estimation even from non-normal populations - Inferential power in small to medium sample sizes - Foundation for statistical decision-making in science, industry, and finance \ud83d\udccc It's one of the most powerful bridges between theory and practice in statistics.","title":"\ud83e\udde0 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \\(\\pi\\) Using Monte Carlo Simulation 1. Theoretical Foundation Monte Carlo methods use randomness to approximate mathematical quantities. In this case, we estimate the value of \\(\\pi\\) by simulating the ratio of points that fall inside a unit circle to the total number of points within a bounding square. Concept: Consider a unit circle (radius = 1) centered at the origin. Enclose the circle in a square that spans from \\(-1\\) to \\(1\\) on both the \\(x\\) - and \\(y\\) -axes. Randomly generate points \\((x, y)\\) uniformly within the square. A point lies inside the circle if it satisfies: \\[x^2 + y^2 \\leq 1\\] The area of the square is: \\[A_{\\text{square}} = (2 \\times 1)^2 = 4\\] The area of the circle is: \\[A_{\\text{circle}} = \\pi \\cdot r^2 = \\pi\\] The ratio of the circle\u2019s area to the square\u2019s area is: \\[\\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4}\\] Hence, if we throw \\(N\\) random points, and \\(M\\) of them fall inside the circle, then: \\[\\frac{M}{N} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{M}{N}\\] 2. Simulation We now implement a simple Monte Carlo simulation in Python to estimate \\(\\pi\\) using the above principle. Steps: Generate \\(N\\) random points \\((x, y)\\) where \\(x, y \\in [-1, 1]\\) Count the number of points \\(M\\) for which \\(x^2 + y^2 \\leq 1\\) Estimate \\(\\pi\\) using the formula: \\[\\pi \\approx 4 \\cdot \\frac{M}{N}\\] 3. Visualization Visualizing the simulation helps to intuitively understand how Monte Carlo methods work in approximating \u03c0. Steps: Each generated point \\((x, y)\\) lies inside a square defined by \\([-1, 1] \\times [-1, 1]\\) . A point lies inside the circle if: \\[x^2 + y^2 \\leq 1\\] In the plot: Use one color (e.g., blue ) for points inside the circle. Use another color (e.g., red ) for points outside the circle. Overlay a dashed boundary representing the unit circle for reference. Benefits: This scatter plot visually confirms that the density of points inside the circle reflects the area ratio \\(\\frac{\\pi}{4}\\) . As more points are added, the filled area more closely approximates the circle. 4. Analysis To understand the effectiveness of the Monte Carlo method, we analyze how the \u03c0 estimate changes as the number of points increases. Experimental Setup: Run the simulation multiple times with increasing values of \\(N\\) (e.g., \\(10^2\\) , \\(10^3\\) , \\(10^4\\) , \\(10^5\\) , \\(10^6\\) ). For each \\(N\\) : Estimate \u03c0 using: \\[\\pi \\approx 4 \\cdot \\frac{M}{N}\\] where: \\(M\\) is the number of points satisfying \\(x^2 + y^2 \\leq 1\\) \\(N\\) is the total number of points Store each \u03c0 estimate and compare it to the actual value of \\(\\pi \\approx 3.1415926535\\) . Convergence: Plot a graph of estimated \u03c0 vs. number of points on a log scale. Observe how the error decreases as \\(N\\) increases. \\[\\text{Error} = \\left| \\pi_{\\text{estimate}} - \\pi \\right|\\] The convergence is probabilistic: The law of large numbers ensures that as \\(N \\to \\infty\\) , the estimate converges to the true value of \u03c0. The standard deviation of the estimate decreases proportionally to \\(\\frac{1}{\\sqrt{N}}\\) . Computational Considerations: Monte Carlo methods are simple to implement but can require a large number of samples for high precision. Execution time grows linearly with \\(N\\) , so optimization or parallelization may be needed for very large simulations. \ud83d\udcc8 Monte Carlo \u03c0 estimation beautifully illustrates the trade-off between accuracy , sample size , and computational cost . Part 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle 1. Theoretical Foundation The Buffon\u2019s Needle experiment is one of the oldest Monte Carlo methods and a classical problem in geometric probability. It provides a probabilistic way to estimate the value of \\(\\pi\\) . Problem Setup: Imagine a floor marked with parallel lines that are equally spaced by a distance \\(d\\) . A needle of length \\(\\ell\\) \\((\\ell \\leq d)\\) is randomly dropped onto the floor. The probability that the needle crosses one of the lines depends on both its length and the spacing between lines. Conditions: The position of the needle's center is uniformly distributed between the lines. The needle\u2019s angle with respect to the parallel lines is uniformly distributed between \\(0\\) and \\(\\frac{\\pi}{2}\\) . Derivation: Let: \\(\\ell\\) = length of the needle \\(d\\) = distance between the lines \\(T\\) = number of needle throws \\(C\\) = number of times the needle crosses a line Then, the expected probability of a crossing is: \\[ P = \\frac{2\\ell}{d\\pi} \\] Rearranging this formula to solve for \\(\\pi\\) gives us an estimate: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot T}{d \\cdot C} \\] 2. Simulation We simulate the dropping of needles on a floor to estimate \\(\\pi\\) using the above formula. Simulation Steps: Define values for: Needle length \\(\\ell\\) Line spacing \\(d\\) \\((\\ell \\leq d)\\) Number of throws \\(T\\) For each throw: Randomly generate: A distance \\(y\\) from the needle\u2019s center to the nearest line (uniformly in \\([0, d/2]\\) ) An angle \\(\\theta\\) between the needle and the lines (uniformly in \\([0, \\pi/2]\\) ) The needle crosses a line if: \\[ y \\leq \\frac{\\ell}{2} \\cdot \\sin(\\theta) \\] Count the number of crossings \\(C\\) . Estimate \\(\\pi\\) as: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot T}{d \\cdot C} \\] Notes: This method relies on geometric probability and converges slowly compared to circle-based Monte Carlo simulations. The accuracy improves with a larger number of needle throws \\(T\\) . Ensure \\(\\ell \\leq d\\) to satisfy classical Buffon\u2019s Needle constraints. \ud83e\uddea Buffon\u2019s Needle is a beautiful example of how geometry and probability can be combined to approximate mathematical constants like \\(\\pi\\) . 3. Visualization To visually demonstrate the geometric basis of Buffon\u2019s Needle experiment, we plot the needle positions over a floor of equally spaced parallel lines. Visual Elements: The floor consists of horizontal parallel lines spaced at distance \\(d\\) apart. Each needle of length \\(\\ell\\) is randomly dropped: A center position \\((x, y)\\) is chosen uniformly at random. An angle \\(\\theta\\) is selected uniformly from \\([0, \\pi]\\) . Each needle is represented as a line segment. If the needle crosses a line , it is shown in red . If the needle does not cross a line , it is shown in green or blue . Mathematical Condition for a Crossing: Let: \\(y\\) = vertical distance from the center of the needle to the nearest line. \\(\\theta\\) = angle the needle makes with the horizontal axis. Then the needle crosses a line if and only if : \\[ y \\leq \\frac{\\ell}{2} \\cdot \\sin(\\theta) \\] This condition is derived from projecting half the length of the needle vertically onto the axis perpendicular to the lines. 4. Analysis To analyze the performance and convergence of Buffon's Needle method, we vary the number of needle drops \\(N\\) and observe how the estimated value of \\(\\pi\\) evolves. Experimental Procedure: Fix: Needle length \\(\\ell\\) (e.g., 1) Line spacing \\(d\\) (e.g., 2, such that \\(\\ell \\leq d\\) ) For increasing values of \\(N\\) (e.g., \\(10^2\\) , \\(10^3\\) , \\(10^4\\) , ..., \\(10^6\\) ): Perform \\(N\\) random needle drops. Count the number of crossings \\(C\\) . Estimate \u03c0 using: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot N}{d \\cdot C} \\] Record and plot: Estimated values of \u03c0. Absolute errors: \\(|\\pi_{\\text{estimate}} - \\pi_{\\text{actual}}|\\) . Convergence Behavior: The error generally decreases as \\(N\\) increases, following a convergence trend similar to: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\] However, this method has slower convergence and higher variance compared to the circle-based Monte Carlo method . Comparison with Circle-Based Monte Carlo: Method Strengths Weaknesses Circle Method Faster convergence, simpler math Requires point-in-circle check Buffon\u2019s Needle Geometric elegance, historical Slower convergence, angle math > \ud83c\udfaf Visual simulations and convergence plots of Buffon\u2019s Needle highlight the probabilistic elegance of this method, while also illustrating its limitations in terms of efficiency compared to other Monte Carlo techniques. Python Codes import numpy as np import matplotlib.pyplot as plt def estimate_pi(num_points=10000, show_plot=True, save_plot=False, filename=\"pi_estimate_plot.png\"): \"\"\" Estimate the value of \u03c0 using Monte Carlo simulation. Parameters: num_points (int): Number of random points to generate. show_plot (bool): Whether to display a scatter plot. save_plot (bool): Whether to save the plot as an image file. filename (str): Filename for saving the plot. Returns: float: Estimated value of \u03c0. \"\"\" # Generate random (x, y) coordinates in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) # Boolean mask for points inside the unit circle inside_circle = x**2 + y**2 <= 1 count_inside = np.sum(inside_circle) # Monte Carlo estimation of \u03c0 pi_estimate = 4 * count_inside / num_points # Plotting if show_plot: plt.figure(figsize=(6, 6)) plt.scatter(x[inside_circle], y[inside_circle], color='dodgerblue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='tomato', s=1, label='Outside Circle') # Draw a unit circle for reference circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=2) plt.gca().add_patch(circle) plt.gca().set_aspect('equal') plt.title(f'\u03c0 Estimation with {num_points:,} Points\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend(loc='upper right') if save_plot: plt.savefig(filename, dpi=300) plt.show() return pi_estimate # Example run estimate_pi(num_points=100000) import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi_convergence(sample_sizes=None): \"\"\" Estimates \u03c0 using Monte Carlo method for increasing sample sizes and plots the convergence of \u03c0 estimates and the corresponding absolute error. Parameters: sample_sizes (list): A list of integers specifying number of points for simulation. \"\"\" if sample_sizes is None: sample_sizes = [10**2, 10**3, 10**4, 10**5, 10**6] pi_actual = np.pi pi_estimates = [] errors = [] # Run simulations for each sample size for N in sample_sizes: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside_circle = x**2 + y**2 <= 1 estimate = 4 * np.sum(inside_circle) / N pi_estimates.append(estimate) errors.append(abs(estimate - pi_actual)) # Set up the figure plt.figure(figsize=(14, 6)) # Plot 1: Estimated \u03c0 vs Number of Points plt.subplot(1, 2, 1) plt.plot(sample_sizes, pi_estimates, 'o--', color='dodgerblue', label='Estimated \u03c0') plt.axhline(pi_actual, color='green', linestyle='-', linewidth=1.5, label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Points (log scale)', fontsize=12) plt.ylabel('Estimated \u03c0', fontsize=12) plt.title('Monte Carlo Estimation of \u03c0', fontsize=14) plt.legend() plt.grid(True, linestyle='--', alpha=0.6) # Plot 2: Absolute Error vs Number of Points plt.subplot(1, 2, 2) plt.plot(sample_sizes, errors, 'o--', color='crimson') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points (log scale)', fontsize=12) plt.ylabel('Absolute Error (log scale)', fontsize=12) plt.title('Convergence of Estimation Error', fontsize=14) plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() # Run the function monte_carlo_pi_convergence() import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Parameters needle_length = 1.0 line_spacing = 2.0 num_needles = 100 line_count = 5 # Generate random positions and angles centers_x = np.random.uniform(0, line_spacing * (line_count - 1), num_needles) centers_y = np.random.uniform(0, line_spacing * line_count, num_needles) angles = np.random.uniform(0, np.pi, num_needles) # Set up the figure fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, line_spacing * (line_count - 1)) ax.set_ylim(0, line_spacing * line_count) ax.set_title(\"\ud83c\udfaf Buffon's Needle Simulation\", fontsize=16, weight='bold') ax.set_xlabel(\"x-position\") ax.set_ylabel(\"y-position\") # Draw floor lines for i in range(line_count + 1): ax.axhline(y=i * line_spacing, color='gray', linestyle='--', linewidth=1) needle_lines = [] def init(): return [] def update(frame): if frame < len(needle_lines): needle_lines[frame].remove() x0 = centers_x[frame] y0 = centers_y[frame] theta = angles[frame] dx = (needle_length / 2) * np.cos(theta) dy = (needle_length / 2) * np.sin(theta) x_start = x0 - dx y_start = y0 - dy x_end = x0 + dx y_end = y0 + dy crosses = int(np.floor(y_start / line_spacing) != np.floor(y_end / line_spacing)) color = '#D7263D' if crosses else '#1B998B' line, = ax.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=2, alpha=0.9) if crosses: ax.plot([x0], [y0], marker='o', color=color, markersize=5) needle_lines.append(line) return [line] ani = animation.FuncAnimation(fig, update, frames=num_needles, init_func=init, blit=True, interval=120, repeat=False) # Save and display the GIF ani.save(\"buffon_creative_simulation.gif\", writer='pillow', fps=10) from IPython.display import Image Image(filename=\"buffon_creative_simulation.gif\") import numpy as np import matplotlib.pyplot as plt # Actual value of \u03c0 pi_actual = np.pi # Simulation parameters needle_length = 1.0 line_spacing = 2.0 sample_sizes = [10**2, 10**3, 10**4, 10**5, 10**6] # Storage for estimates and errors buffon_estimates = [] buffon_errors = [] circle_estimates = [] circle_errors = [] # Run both simulations for each sample size for N in sample_sizes: # --- Buffon's Needle --- y = np.random.uniform(0, line_spacing / 2, N) theta = np.random.uniform(0, np.pi / 2, N) crosses = y <= (needle_length / 2) * np.sin(theta) crossings = np.sum(crosses) if crossings == 0: buffon_estimate = np.nan # avoid division by zero else: buffon_estimate = (2 * needle_length * N) / (line_spacing * crossings) buffon_estimates.append(buffon_estimate) buffon_errors.append(abs(buffon_estimate - pi_actual) if crossings > 0 else np.nan) # --- Monte Carlo Circle --- x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = x**2 + y**2 <= 1 circle_estimate = 4 * np.sum(inside) / N circle_estimates.append(circle_estimate) circle_errors.append(abs(circle_estimate - pi_actual)) # --- Plotting --- fig, axs = plt.subplots(2, 2, figsize=(14, 10)) # 1. \u03c0 Estimates axs[0, 0].plot(sample_sizes, buffon_estimates, 'o--', label=\"Buffon's Needle\", color='red') axs[0, 0].plot(sample_sizes, circle_estimates, 's--', label='Monte Carlo (Circle)', color='blue') axs[0, 0].axhline(pi_actual, color='green', linestyle='-', linewidth=1.5, label='Actual \u03c0') axs[0, 0].set_xscale('log') axs[0, 0].set_title('Estimated \u03c0 vs. Sample Size') axs[0, 0].set_xlabel('Number of Points (log scale)') axs[0, 0].set_ylabel('Estimated \u03c0') axs[0, 0].legend() axs[0, 0].grid(True) # 2. Absolute Errors axs[0, 1].plot(sample_sizes, buffon_errors, 'o--', label=\"Buffon's Needle\", color='red') axs[0, 1].plot(sample_sizes, circle_errors, 's--', label='Monte Carlo (Circle)', color='blue') axs[0, 1].set_xscale('log') axs[0, 1].set_yscale('log') axs[0, 1].set_title('Absolute Error vs. Sample Size') axs[0, 1].set_xlabel('Number of Points (log scale)') axs[0, 1].set_ylabel('Absolute Error (log-log scale)') axs[0, 1].legend() axs[0, 1].grid(True) # 3. Buffon's Needle Estimates axs[1, 0].plot(sample_sizes, buffon_estimates, 'o-', color='red') axs[1, 0].axhline(pi_actual, color='green', linestyle='--') axs[1, 0].set_xscale('log') axs[1, 0].set_title(\"Buffon's Needle \u03c0 Estimate\") axs[1, 0].set_xlabel('Sample Size (log scale)') axs[1, 0].set_ylabel('\u03c0 Estimate') axs[1, 0].grid(True) # 4. Circle Method Estimates axs[1, 1].plot(sample_sizes, circle_estimates, 'o-', color='blue') axs[1, 1].axhline(pi_actual, color='green', linestyle='--') axs[1, 1].set_xscale('log') axs[1, 1].set_title(\"Monte Carlo Circle \u03c0 Estimate\") axs[1, 1].set_xlabel('Sample Size (log scale)') axs[1, 1].set_ylabel('\u03c0 Estimate') axs[1, 1].grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Settings frame_points = 500 total_frames = 100 total_points = frame_points * total_frames np.random.seed(42) x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) # Set up the plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1, 1) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.set_title(\"Monte Carlo Simulation: Estimating \u03c0\", fontsize=14, weight='bold') ax.set_xlabel(\"x-axis\") ax.set_ylabel(\"y-axis\") # Draw circle outline circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=2) ax.add_patch(circle) # Prepare point plots inside = ax.plot([], [], 'o', color='#2a9d8f', markersize=2, label='Inside Circle')[0] outside = ax.plot([], [], 'o', color='#e76f51', markersize=2, label='Outside Circle')[0] # Create text: top left (small), middle (larger) text_total = ax.text(-0.95, 1.13, \"\", fontsize=9, bbox=dict(facecolor='white', alpha=0.7, edgecolor='gray')) text_pi = ax.text(-0.95, 1.05, \"\", fontsize=11, bbox=dict(facecolor='white', alpha=0.7, edgecolor='gray')) def init(): inside.set_data([], []) outside.set_data([], []) text_total.set_text(\"\") text_pi.set_text(\"\") return inside, outside, text_total, text_pi def update(frame): end = (frame + 1) * frame_points x_f = x[:end] y_f = y[:end] inside_mask = x_f**2 + y_f**2 <= 1 inside.set_data(x_f[inside_mask], y_f[inside_mask]) outside.set_data(x_f[~inside_mask], y_f[~inside_mask]) pi_est = 4 * np.sum(inside_mask) / len(x_f) text_total.set_text(f\"Total Points: {len(x_f)}\") text_pi.set_text(f\"Estimated \u03c0 \u2248 {pi_est:.6f}\") return inside, outside, text_total, text_pi ani = animation.FuncAnimation(fig, update, frames=total_frames, init_func=init, blit=True, interval=100, repeat=False) # Save GIF ani.save(\"monte_carlo_pi_estimation_final.gif\", writer='pillow', fps=10) # Show in Colab from IPython.display import Image Image(filename=\"monte_carlo_pi_estimation_final.gif\")","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-simulation","text":"","title":"Estimating \\(\\pi\\) Using Monte Carlo Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Monte Carlo methods use randomness to approximate mathematical quantities. In this case, we estimate the value of \\(\\pi\\) by simulating the ratio of points that fall inside a unit circle to the total number of points within a bounding square.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#concept","text":"Consider a unit circle (radius = 1) centered at the origin. Enclose the circle in a square that spans from \\(-1\\) to \\(1\\) on both the \\(x\\) - and \\(y\\) -axes. Randomly generate points \\((x, y)\\) uniformly within the square. A point lies inside the circle if it satisfies: \\[x^2 + y^2 \\leq 1\\] The area of the square is: \\[A_{\\text{square}} = (2 \\times 1)^2 = 4\\] The area of the circle is: \\[A_{\\text{circle}} = \\pi \\cdot r^2 = \\pi\\] The ratio of the circle\u2019s area to the square\u2019s area is: \\[\\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4}\\] Hence, if we throw \\(N\\) random points, and \\(M\\) of them fall inside the circle, then: \\[\\frac{M}{N} \\approx \\frac{\\pi}{4} \\Rightarrow \\pi \\approx 4 \\cdot \\frac{M}{N}\\]","title":"Concept:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"We now implement a simple Monte Carlo simulation in Python to estimate \\(\\pi\\) using the above principle.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#steps","text":"Generate \\(N\\) random points \\((x, y)\\) where \\(x, y \\in [-1, 1]\\) Count the number of points \\(M\\) for which \\(x^2 + y^2 \\leq 1\\) Estimate \\(\\pi\\) using the formula: \\[\\pi \\approx 4 \\cdot \\frac{M}{N}\\]","title":"Steps:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Visualizing the simulation helps to intuitively understand how Monte Carlo methods work in approximating \u03c0.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#steps_1","text":"Each generated point \\((x, y)\\) lies inside a square defined by \\([-1, 1] \\times [-1, 1]\\) . A point lies inside the circle if: \\[x^2 + y^2 \\leq 1\\] In the plot: Use one color (e.g., blue ) for points inside the circle. Use another color (e.g., red ) for points outside the circle. Overlay a dashed boundary representing the unit circle for reference.","title":"Steps:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#benefits","text":"This scatter plot visually confirms that the density of points inside the circle reflects the area ratio \\(\\frac{\\pi}{4}\\) . As more points are added, the filled area more closely approximates the circle.","title":"Benefits:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"To understand the effectiveness of the Monte Carlo method, we analyze how the \u03c0 estimate changes as the number of points increases.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#experimental-setup","text":"Run the simulation multiple times with increasing values of \\(N\\) (e.g., \\(10^2\\) , \\(10^3\\) , \\(10^4\\) , \\(10^5\\) , \\(10^6\\) ). For each \\(N\\) : Estimate \u03c0 using: \\[\\pi \\approx 4 \\cdot \\frac{M}{N}\\] where: \\(M\\) is the number of points satisfying \\(x^2 + y^2 \\leq 1\\) \\(N\\) is the total number of points Store each \u03c0 estimate and compare it to the actual value of \\(\\pi \\approx 3.1415926535\\) .","title":"Experimental Setup:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence","text":"Plot a graph of estimated \u03c0 vs. number of points on a log scale. Observe how the error decreases as \\(N\\) increases. \\[\\text{Error} = \\left| \\pi_{\\text{estimate}} - \\pi \\right|\\] The convergence is probabilistic: The law of large numbers ensures that as \\(N \\to \\infty\\) , the estimate converges to the true value of \u03c0. The standard deviation of the estimate decreases proportionally to \\(\\frac{1}{\\sqrt{N}}\\) .","title":"Convergence:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#computational-considerations","text":"Monte Carlo methods are simple to implement but can require a large number of samples for high precision. Execution time grows linearly with \\(N\\) , so optimization or parallelization may be needed for very large simulations. \ud83d\udcc8 Monte Carlo \u03c0 estimation beautifully illustrates the trade-off between accuracy , sample size , and computational cost .","title":"Computational Considerations:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"Part 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"The Buffon\u2019s Needle experiment is one of the oldest Monte Carlo methods and a classical problem in geometric probability. It provides a probabilistic way to estimate the value of \\(\\pi\\) .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-setup","text":"Imagine a floor marked with parallel lines that are equally spaced by a distance \\(d\\) . A needle of length \\(\\ell\\) \\((\\ell \\leq d)\\) is randomly dropped onto the floor. The probability that the needle crosses one of the lines depends on both its length and the spacing between lines.","title":"Problem Setup:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conditions","text":"The position of the needle's center is uniformly distributed between the lines. The needle\u2019s angle with respect to the parallel lines is uniformly distributed between \\(0\\) and \\(\\frac{\\pi}{2}\\) .","title":"Conditions:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#derivation","text":"Let: \\(\\ell\\) = length of the needle \\(d\\) = distance between the lines \\(T\\) = number of needle throws \\(C\\) = number of times the needle crosses a line Then, the expected probability of a crossing is: \\[ P = \\frac{2\\ell}{d\\pi} \\] Rearranging this formula to solve for \\(\\pi\\) gives us an estimate: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot T}{d \\cdot C} \\]","title":"Derivation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"We simulate the dropping of needles on a floor to estimate \\(\\pi\\) using the above formula.","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-steps","text":"Define values for: Needle length \\(\\ell\\) Line spacing \\(d\\) \\((\\ell \\leq d)\\) Number of throws \\(T\\) For each throw: Randomly generate: A distance \\(y\\) from the needle\u2019s center to the nearest line (uniformly in \\([0, d/2]\\) ) An angle \\(\\theta\\) between the needle and the lines (uniformly in \\([0, \\pi/2]\\) ) The needle crosses a line if: \\[ y \\leq \\frac{\\ell}{2} \\cdot \\sin(\\theta) \\] Count the number of crossings \\(C\\) . Estimate \\(\\pi\\) as: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot T}{d \\cdot C} \\]","title":"Simulation Steps:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#notes","text":"This method relies on geometric probability and converges slowly compared to circle-based Monte Carlo simulations. The accuracy improves with a larger number of needle throws \\(T\\) . Ensure \\(\\ell \\leq d\\) to satisfy classical Buffon\u2019s Needle constraints. \ud83e\uddea Buffon\u2019s Needle is a beautiful example of how geometry and probability can be combined to approximate mathematical constants like \\(\\pi\\) .","title":"Notes:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"To visually demonstrate the geometric basis of Buffon\u2019s Needle experiment, we plot the needle positions over a floor of equally spaced parallel lines.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visual-elements","text":"The floor consists of horizontal parallel lines spaced at distance \\(d\\) apart. Each needle of length \\(\\ell\\) is randomly dropped: A center position \\((x, y)\\) is chosen uniformly at random. An angle \\(\\theta\\) is selected uniformly from \\([0, \\pi]\\) . Each needle is represented as a line segment. If the needle crosses a line , it is shown in red . If the needle does not cross a line , it is shown in green or blue .","title":"Visual Elements:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#mathematical-condition-for-a-crossing","text":"Let: \\(y\\) = vertical distance from the center of the needle to the nearest line. \\(\\theta\\) = angle the needle makes with the horizontal axis. Then the needle crosses a line if and only if : \\[ y \\leq \\frac{\\ell}{2} \\cdot \\sin(\\theta) \\] This condition is derived from projecting half the length of the needle vertically onto the axis perpendicular to the lines.","title":"Mathematical Condition for a Crossing:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"To analyze the performance and convergence of Buffon's Needle method, we vary the number of needle drops \\(N\\) and observe how the estimated value of \\(\\pi\\) evolves.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#experimental-procedure","text":"Fix: Needle length \\(\\ell\\) (e.g., 1) Line spacing \\(d\\) (e.g., 2, such that \\(\\ell \\leq d\\) ) For increasing values of \\(N\\) (e.g., \\(10^2\\) , \\(10^3\\) , \\(10^4\\) , ..., \\(10^6\\) ): Perform \\(N\\) random needle drops. Count the number of crossings \\(C\\) . Estimate \u03c0 using: \\[ \\pi \\approx \\frac{2 \\cdot \\ell \\cdot N}{d \\cdot C} \\] Record and plot: Estimated values of \u03c0. Absolute errors: \\(|\\pi_{\\text{estimate}} - \\pi_{\\text{actual}}|\\) .","title":"Experimental Procedure:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-behavior","text":"The error generally decreases as \\(N\\) increases, following a convergence trend similar to: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\] However, this method has slower convergence and higher variance compared to the circle-based Monte Carlo method .","title":"Convergence Behavior:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-with-circle-based-monte-carlo","text":"Method Strengths Weaknesses Circle Method Faster convergence, simpler math Requires point-in-circle check Buffon\u2019s Needle Geometric elegance, historical Slower convergence, angle math","title":"Comparison with Circle-Based Monte Carlo:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visual-simulations-and-convergence-plots-of-buffons-needle-highlight-the-probabilistic-elegance-of-this-method-while-also-illustrating-its-limitations-in-terms-of-efficiency-compared-to-other-monte-carlo-techniques","text":"","title":"&gt; \ud83c\udfaf Visual simulations and convergence plots of Buffon\u2019s Needle highlight the probabilistic elegance of this method, while also illustrating its limitations in terms of efficiency compared to other Monte Carlo techniques."},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-codes","text":"import numpy as np import matplotlib.pyplot as plt def estimate_pi(num_points=10000, show_plot=True, save_plot=False, filename=\"pi_estimate_plot.png\"): \"\"\" Estimate the value of \u03c0 using Monte Carlo simulation. Parameters: num_points (int): Number of random points to generate. show_plot (bool): Whether to display a scatter plot. save_plot (bool): Whether to save the plot as an image file. filename (str): Filename for saving the plot. Returns: float: Estimated value of \u03c0. \"\"\" # Generate random (x, y) coordinates in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) # Boolean mask for points inside the unit circle inside_circle = x**2 + y**2 <= 1 count_inside = np.sum(inside_circle) # Monte Carlo estimation of \u03c0 pi_estimate = 4 * count_inside / num_points # Plotting if show_plot: plt.figure(figsize=(6, 6)) plt.scatter(x[inside_circle], y[inside_circle], color='dodgerblue', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='tomato', s=1, label='Outside Circle') # Draw a unit circle for reference circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=2) plt.gca().add_patch(circle) plt.gca().set_aspect('equal') plt.title(f'\u03c0 Estimation with {num_points:,} Points\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}') plt.xlabel('x') plt.ylabel('y') plt.grid(True) plt.legend(loc='upper right') if save_plot: plt.savefig(filename, dpi=300) plt.show() return pi_estimate # Example run estimate_pi(num_points=100000) import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi_convergence(sample_sizes=None): \"\"\" Estimates \u03c0 using Monte Carlo method for increasing sample sizes and plots the convergence of \u03c0 estimates and the corresponding absolute error. Parameters: sample_sizes (list): A list of integers specifying number of points for simulation. \"\"\" if sample_sizes is None: sample_sizes = [10**2, 10**3, 10**4, 10**5, 10**6] pi_actual = np.pi pi_estimates = [] errors = [] # Run simulations for each sample size for N in sample_sizes: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside_circle = x**2 + y**2 <= 1 estimate = 4 * np.sum(inside_circle) / N pi_estimates.append(estimate) errors.append(abs(estimate - pi_actual)) # Set up the figure plt.figure(figsize=(14, 6)) # Plot 1: Estimated \u03c0 vs Number of Points plt.subplot(1, 2, 1) plt.plot(sample_sizes, pi_estimates, 'o--', color='dodgerblue', label='Estimated \u03c0') plt.axhline(pi_actual, color='green', linestyle='-', linewidth=1.5, label='Actual \u03c0') plt.xscale('log') plt.xlabel('Number of Points (log scale)', fontsize=12) plt.ylabel('Estimated \u03c0', fontsize=12) plt.title('Monte Carlo Estimation of \u03c0', fontsize=14) plt.legend() plt.grid(True, linestyle='--', alpha=0.6) # Plot 2: Absolute Error vs Number of Points plt.subplot(1, 2, 2) plt.plot(sample_sizes, errors, 'o--', color='crimson') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points (log scale)', fontsize=12) plt.ylabel('Absolute Error (log scale)', fontsize=12) plt.title('Convergence of Estimation Error', fontsize=14) plt.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() # Run the function monte_carlo_pi_convergence() import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Parameters needle_length = 1.0 line_spacing = 2.0 num_needles = 100 line_count = 5 # Generate random positions and angles centers_x = np.random.uniform(0, line_spacing * (line_count - 1), num_needles) centers_y = np.random.uniform(0, line_spacing * line_count, num_needles) angles = np.random.uniform(0, np.pi, num_needles) # Set up the figure fig, ax = plt.subplots(figsize=(10, 6)) ax.set_xlim(0, line_spacing * (line_count - 1)) ax.set_ylim(0, line_spacing * line_count) ax.set_title(\"\ud83c\udfaf Buffon's Needle Simulation\", fontsize=16, weight='bold') ax.set_xlabel(\"x-position\") ax.set_ylabel(\"y-position\") # Draw floor lines for i in range(line_count + 1): ax.axhline(y=i * line_spacing, color='gray', linestyle='--', linewidth=1) needle_lines = [] def init(): return [] def update(frame): if frame < len(needle_lines): needle_lines[frame].remove() x0 = centers_x[frame] y0 = centers_y[frame] theta = angles[frame] dx = (needle_length / 2) * np.cos(theta) dy = (needle_length / 2) * np.sin(theta) x_start = x0 - dx y_start = y0 - dy x_end = x0 + dx y_end = y0 + dy crosses = int(np.floor(y_start / line_spacing) != np.floor(y_end / line_spacing)) color = '#D7263D' if crosses else '#1B998B' line, = ax.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=2, alpha=0.9) if crosses: ax.plot([x0], [y0], marker='o', color=color, markersize=5) needle_lines.append(line) return [line] ani = animation.FuncAnimation(fig, update, frames=num_needles, init_func=init, blit=True, interval=120, repeat=False) # Save and display the GIF ani.save(\"buffon_creative_simulation.gif\", writer='pillow', fps=10) from IPython.display import Image Image(filename=\"buffon_creative_simulation.gif\") import numpy as np import matplotlib.pyplot as plt # Actual value of \u03c0 pi_actual = np.pi # Simulation parameters needle_length = 1.0 line_spacing = 2.0 sample_sizes = [10**2, 10**3, 10**4, 10**5, 10**6] # Storage for estimates and errors buffon_estimates = [] buffon_errors = [] circle_estimates = [] circle_errors = [] # Run both simulations for each sample size for N in sample_sizes: # --- Buffon's Needle --- y = np.random.uniform(0, line_spacing / 2, N) theta = np.random.uniform(0, np.pi / 2, N) crosses = y <= (needle_length / 2) * np.sin(theta) crossings = np.sum(crosses) if crossings == 0: buffon_estimate = np.nan # avoid division by zero else: buffon_estimate = (2 * needle_length * N) / (line_spacing * crossings) buffon_estimates.append(buffon_estimate) buffon_errors.append(abs(buffon_estimate - pi_actual) if crossings > 0 else np.nan) # --- Monte Carlo Circle --- x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = x**2 + y**2 <= 1 circle_estimate = 4 * np.sum(inside) / N circle_estimates.append(circle_estimate) circle_errors.append(abs(circle_estimate - pi_actual)) # --- Plotting --- fig, axs = plt.subplots(2, 2, figsize=(14, 10)) # 1. \u03c0 Estimates axs[0, 0].plot(sample_sizes, buffon_estimates, 'o--', label=\"Buffon's Needle\", color='red') axs[0, 0].plot(sample_sizes, circle_estimates, 's--', label='Monte Carlo (Circle)', color='blue') axs[0, 0].axhline(pi_actual, color='green', linestyle='-', linewidth=1.5, label='Actual \u03c0') axs[0, 0].set_xscale('log') axs[0, 0].set_title('Estimated \u03c0 vs. Sample Size') axs[0, 0].set_xlabel('Number of Points (log scale)') axs[0, 0].set_ylabel('Estimated \u03c0') axs[0, 0].legend() axs[0, 0].grid(True) # 2. Absolute Errors axs[0, 1].plot(sample_sizes, buffon_errors, 'o--', label=\"Buffon's Needle\", color='red') axs[0, 1].plot(sample_sizes, circle_errors, 's--', label='Monte Carlo (Circle)', color='blue') axs[0, 1].set_xscale('log') axs[0, 1].set_yscale('log') axs[0, 1].set_title('Absolute Error vs. Sample Size') axs[0, 1].set_xlabel('Number of Points (log scale)') axs[0, 1].set_ylabel('Absolute Error (log-log scale)') axs[0, 1].legend() axs[0, 1].grid(True) # 3. Buffon's Needle Estimates axs[1, 0].plot(sample_sizes, buffon_estimates, 'o-', color='red') axs[1, 0].axhline(pi_actual, color='green', linestyle='--') axs[1, 0].set_xscale('log') axs[1, 0].set_title(\"Buffon's Needle \u03c0 Estimate\") axs[1, 0].set_xlabel('Sample Size (log scale)') axs[1, 0].set_ylabel('\u03c0 Estimate') axs[1, 0].grid(True) # 4. Circle Method Estimates axs[1, 1].plot(sample_sizes, circle_estimates, 'o-', color='blue') axs[1, 1].axhline(pi_actual, color='green', linestyle='--') axs[1, 1].set_xscale('log') axs[1, 1].set_title(\"Monte Carlo Circle \u03c0 Estimate\") axs[1, 1].set_xlabel('Sample Size (log scale)') axs[1, 1].set_ylabel('\u03c0 Estimate') axs[1, 1].grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # Settings frame_points = 500 total_frames = 100 total_points = frame_points * total_frames np.random.seed(42) x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) # Set up the plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1, 1) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.set_title(\"Monte Carlo Simulation: Estimating \u03c0\", fontsize=14, weight='bold') ax.set_xlabel(\"x-axis\") ax.set_ylabel(\"y-axis\") # Draw circle outline circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=2) ax.add_patch(circle) # Prepare point plots inside = ax.plot([], [], 'o', color='#2a9d8f', markersize=2, label='Inside Circle')[0] outside = ax.plot([], [], 'o', color='#e76f51', markersize=2, label='Outside Circle')[0] # Create text: top left (small), middle (larger) text_total = ax.text(-0.95, 1.13, \"\", fontsize=9, bbox=dict(facecolor='white', alpha=0.7, edgecolor='gray')) text_pi = ax.text(-0.95, 1.05, \"\", fontsize=11, bbox=dict(facecolor='white', alpha=0.7, edgecolor='gray')) def init(): inside.set_data([], []) outside.set_data([], []) text_total.set_text(\"\") text_pi.set_text(\"\") return inside, outside, text_total, text_pi def update(frame): end = (frame + 1) * frame_points x_f = x[:end] y_f = y[:end] inside_mask = x_f**2 + y_f**2 <= 1 inside.set_data(x_f[inside_mask], y_f[inside_mask]) outside.set_data(x_f[~inside_mask], y_f[~inside_mask]) pi_est = 4 * np.sum(inside_mask) / len(x_f) text_total.set_text(f\"Total Points: {len(x_f)}\") text_pi.set_text(f\"Estimated \u03c0 \u2248 {pi_est:.6f}\") return inside, outside, text_total, text_pi ani = animation.FuncAnimation(fig, update, frames=total_frames, init_func=init, blit=True, interval=100, repeat=False) # Save GIF ani.save(\"monte_carlo_pi_estimation_final.gif\", writer='pillow', fps=10) # Show in Colab from IPython.display import Image Image(filename=\"monte_carlo_pi_estimation_final.gif\")","title":"Python Codes"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83d\udccf Measuring Earth's Gravitational Acceleration with a Pendulum \ud83e\uddea Materials & Setup \u2705 Materials Needed A string (~1 or 1.5 meters long) A small weight (e.g., bag of coins, sugar, or a keychain) A stopwatch or smartphone timer A ruler or measuring tape \ud83d\udd27 Experimental Setup Construct the Pendulum Attach the weight to one end of the string and secure the other end to a sturdy support, allowing it to swing freely. Measure Pendulum Length Measure the length \\(L\\) from the suspension point to the center of mass of the weight. Record this value carefully using a ruler or tape measure. Note Instrument Resolution Record the resolution of the measuring instrument (typically in centimeters or millimeters). Calculate Uncertainty in Length Measurement Use the formula: \\[\\Delta L=\\frac{\\text{Resolution of Ruler}}{2}\\] This represents the uncertainty due to the finite precision of your measuring tool. For example, if the smallest division is 1 mm, then: \\( \\(\\Delta L=\\frac{1\\,\\text{mm}}{2}=0.5\\,\\text{mm}=0.0005\\,\\text{m}\\) \\) \ud83d\udccc Summary of Setup Values (Example Format) Quantity Symbol Value Units Notes Pendulum Length \\(L\\) 1.200 m Measured from pivot to mass center Ruler Resolution \u2013 1 mm Smallest readable unit Uncertainty in \\(L\\) \\(\\Delta L\\) 0.0005 m \\(\\Delta L=\\frac{1}{2}\\,\\text{mm}\\) \u23f1\ufe0f Data Collection \ud83c\udf00 Procedure Displace the pendulum to an angle less than \\(15^\\circ\\) and release it gently. Measure the time it takes for 10 full oscillations . Denote this time as \\(T_{10}\\) . Repeat the measurement a total of 10 times to collect a reliable data set. \ud83e\uddfe Record Measurements Collect and tabulate all 10 values of \\(T_{10}\\) . Use a table like the following: Trial \\(T_{10}\\) (s) 1 2 ... 10 \ud83d\udcca Statistical Analysis Calculate the mean time for 10 oscillations: \\[ \\overline{T}_{10} = \\frac{1}{n} \\sum_{i=1}^{n} T_{10}^{(i)} \\] where \\(n = 10\\) and \\(T_{10}^{(i)}\\) is the time from the \\(i^{\\text{th}}\\) trial. Compute the standard deviation of the \\(T_{10}\\) values: \\[ \\sigma_T = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} \\left(T_{10}^{(i)} - \\overline{T}_{10}\\right)^2} \\] Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\] This represents the standard error of the mean , which quantifies the precision of your mean timing result. \ud83e\uddee Example Output Table Quantity Symbol Formula Units Mean of 10 times \\(\\overline{T}_{10}\\) \\(\\frac{1}{n} \\sum T_{10}^{(i)}\\) s Standard deviation \\(\\sigma_T\\) \\(\\sqrt{\\frac{1}{n-1} \\sum (T_{10}-\\overline{T}_{10})^2}\\) s Uncertainty in mean \\(\\Delta T_{10}\\) \\(\\frac{\\sigma_T}{\\sqrt{n}}\\) s \ud83d\udcda Analysis \u2705 Comparison with Standard Value The experimentally determined value of gravitational acceleration is: \\[ g_{\\text{measured}} = \\frac{4\\pi^2 L}{T^2} \\] The standard accepted value is: \\[ g_{\\text{standard}} = 9.81\\, \\text{m/s}^2 \\] Compare the measured value of \\(g\\) with \\(9.81\\, \\text{m/s}^2\\) . If the two values agree within the uncertainty \\(\\Delta g\\) , the experiment can be considered successful. Consider the relative error: \\[ \\text{Relative Error} = \\frac{|g_{\\text{measured}} - g_{\\text{standard}}|}{g_{\\text{standard}}} \\times 100\\% \\] \ud83e\uddfe Uncertainty Discussion \ud83d\udd2c Effect of Measurement Resolution on \\(\\Delta L\\) The uncertainty in length, \\(\\Delta L\\) , is directly related to the resolution of the measuring instrument : \\[ \\Delta L = \\frac{\\text{Resolution}}{2} \\] If the ruler has a coarse resolution (e.g., 1 cm), this increases \\(\\Delta L\\) , and in turn, increases the total uncertainty \\(\\Delta g\\) via: \\[ \\Delta g \\propto \\frac{\\Delta L}{L} \\] Better measuring tools (e.g., a caliper or laser ruler) would reduce \\(\\Delta L\\) and improve the accuracy of \\(g\\) . \u23f1\ufe0f Impact of Timing Variability on \\(\\Delta T\\) The time measurements are subjective if done manually, leading to random errors. Timing variability is quantified by the standard deviation \\(\\sigma_T\\) and the uncertainty in the mean: \\[ \\Delta T = \\frac{\\sigma_T}{\\sqrt{n} \\cdot 10} \\] This impacts the uncertainty in \\(g\\) quadratically: \\[ \\Delta g \\propto 2 \\cdot \\frac{\\Delta T}{T} \\] Using photogates or electronic timers would minimize this variability significantly. \u26a0\ufe0f Assumptions and Limitations The angle of release is assumed to be small ( \\(< 15^\\circ\\) ) so that the pendulum follows simple harmonic motion . Air resistance and friction at the pivot are neglected . The string is assumed to be massless and inextensible . The center of mass of the bob is assumed to be clearly defined and accurately measurable . Human reaction time introduces systematic uncertainty in timing. \ud83d\udccc Conclusion Ensure that the final reported value of \\(g\\) is written with its uncertainty : \\[ g = g_{\\text{measured}} \\pm \\Delta g \\quad \\text{(in m/s}^2\\text{)} \\] Evaluate whether this range includes the accepted value \\(9.81\\, \\text{m/s}^2\\) . Python Codes # \u25b6\ufe0f Install required library (only needed once in Colab) !pip install -q pillow import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter # === Physics Constants === L = 1.2 # Pendulum length in meters theta_max = np.radians(15) # Max angular displacement g = 9.81 # Gravitational acceleration omega = np.sqrt(g / L) period = 2 * np.pi * np.sqrt(L / g) t_vals = np.linspace(0, 2 * period, 100) # === Set up figure and axis === fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.4, 1.4) ax.set_ylim(-1.6, 0.4) ax.set_aspect('equal') ax.axis('off') # Hide axes # === Pendulum Graphics === line, = ax.plot([], [], lw=3, color='#0077b6') bob = plt.Circle((0, -L), 0.06, color='#f72585', zorder=5) ax.add_patch(bob) # === Static Text Annotations (positioned safely outside swing) === length_label = ax.text(0, 0.3, \"$L = 1.2\\\\,\\\\mathrm{m}$\", fontsize=13, ha='center', bbox=dict(facecolor='wheat', edgecolor='black')) angle_label = ax.text(1.1, -1.3, \"\", fontsize=12, color='black', bbox=dict(facecolor='lightgray', edgecolor='gray')) # === Animation Function === def animate(i): t = t_vals[i] theta = theta_max * np.cos(omega * t) x = L * np.sin(theta) y = -L * np.cos(theta) # Update pendulum position line.set_data([0, x], [0, y]) bob.center = (x, y) # Update angle text angle_deg = np.degrees(theta) angle_label.set_text(f\"$\\\\theta = {angle_deg:.1f}^\\\\circ$\") return line, bob, angle_label # === Create Animation === ani = FuncAnimation(fig, animate, frames=len(t_vals), interval=50, blit=True) # Save as GIF gif_path = \"/content/pendulum_setup_clean.gif\" ani.save(gif_path, writer=PillowWriter(fps=20)) plt.close() # Display GIF from IPython.display import Image Image(filename=gif_path) import matplotlib.pyplot as plt import numpy as np # === \ud83d\udd22 Input Your Experimental Results === g_measured = 9.77 # replace with your measured g delta_g = 0.10 # replace with your uncertainty in g g_standard = 9.81 # standard gravity # === \u2699\ufe0f Data Setup === positions = [0, 1] labels = ['Measured $g$', 'Standard $g$'] values = [g_measured, g_standard] errors = [delta_g, 0] # Only measured g has uncertainty colors = ['#00b4d8', '#90be6d'] # measured and standard # === \ud83d\udcca Create Plot === fig, ax = plt.subplots(figsize=(10, 6)) bars = ax.bar( positions, values, yerr=errors, capsize=10, color=colors, edgecolor='black', alpha=0.9 ) # === \ud83d\udccd Annotate Bars === ax.text( positions[0], g_measured + delta_g + 0.1, f\"$g_{{measured}} = {g_measured:.2f} \\pm {delta_g:.2f}$ m/s\u00b2\", ha='center', fontsize=12, bbox=dict(boxstyle=\"round,pad=0.4\", fc=\"#ffd6a5\", ec=\"black\", alpha=0.85) ) ax.text( positions[1], g_standard + 0.1, f\"$g_{{standard}} = {g_standard:.2f}$ m/s\u00b2\", ha='center', fontsize=12, bbox=dict(boxstyle=\"round,pad=0.4\", fc=\"#d0f4de\", ec=\"black\", alpha=0.85) ) # === \ud83d\udcd8 Additional Explanation === ax.annotate( \"Uncertainty range\\n(\u00b1 \u0394g)\", xy=(0, g_measured + delta_g), xytext=(0.1, g_measured + delta_g + 0.6), arrowprops=dict(arrowstyle=\"->\", color='black'), fontsize=11, bbox=dict(boxstyle=\"round\", fc=\"#fefae0\", ec=\"gray\", alpha=0.9) ) # === \ud83c\udfa8 Styling === ax.set_title(\"\ud83c\udf0d Comparison of Measured vs Standard Gravitational Acceleration\", fontsize=16, weight='bold') ax.set_ylabel(\"Gravitational Acceleration (m/s\u00b2)\", fontsize=13) ax.set_xticks(positions) ax.set_xticklabels(labels, fontsize=12) ax.set_ylim(0, max(g_measured + delta_g, g_standard) + 1) # Add horizontal reference line ax.axhline(g_standard, color='#6a994e', linestyle='--', linewidth=1.5, alpha=0.7) # Grid ax.yaxis.grid(True, linestyle='--', alpha=0.5) # Final layout plt.tight_layout() plt.show() # \u2705 Pendulum Gravity Measurement Tool with Beautiful Plot import numpy as np import matplotlib.pyplot as plt # \ud83d\udce5 Your 10 measurements of T_10 (in seconds) T_10_measurements = np.array([21.40, 21.52, 21.47, 21.35, 21.60, 21.43, 21.50, 21.44, 21.38, 21.46]) # \u2699\ufe0f Constants n = len(T_10_measurements) ruler_resolution_mm = 1.0 # mm L = 1.200 # pendulum length in meters delta_L = (ruler_resolution_mm / 1000) / 2 # Convert mm to m, divide by 2 # \ud83d\udcca Stats calculations T10_mean = np.mean(T_10_measurements) sigma_T = np.std(T_10_measurements, ddof=1) delta_T10 = sigma_T / np.sqrt(n) T = T10_mean / 10 delta_T = delta_T10 / 10 g = (4 * np.pi**2 * L) / (T**2) delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) # \ud83d\udda8\ufe0f Results print(\"=== Results ===\") print(f\"Mean T_10 = {T10_mean:.4f} s\") print(f\"Standard deviation \u03c3_T = {sigma_T:.4f} s\") print(f\"Uncertainty in mean \u0394T_10 = {delta_T10:.4f} s\") print(f\"Single period T = {T:.4f} \u00b1 {delta_T:.4f} s\") print(f\"g = {g:.4f} \u00b1 {delta_g:.4f} m/s\u00b2\") # \ud83c\udfa8 Plot fig, ax = plt.subplots(figsize=(10, 6)) x = np.arange(1, n + 1) # Error bars and points ax.errorbar(x, T_10_measurements, yerr=delta_T10, fmt='o', color='teal', ecolor='salmon', elinewidth=2, capsize=5, label='T\u2081\u2080 Measurements') # Mean line ax.axhline(T10_mean, color='orange', linestyle='--', linewidth=2, label=f'Mean = {T10_mean:.2f} s') # Labels and Title ax.set_title(\"Pendulum Timing Measurements ($T_{10}$)\", fontsize=16, weight='bold') ax.set_xlabel(\"Trial Number\", fontsize=13) ax.set_ylabel(\"Time for 10 Oscillations (s)\", fontsize=13) ax.grid(True, linestyle='--', alpha=0.5) ax.legend(fontsize=12) # Annotation box textstr = '\\n'.join(( f'$\\overline{{T_{{10}}}}$ = {T10_mean:.2f} s', f'$\\sigma_T$ = {sigma_T:.3f} s', f'$\\\\Delta T_{{10}}$ = {delta_T10:.3f} s', f'$T$ = {T:.3f} s \u00b1 {delta_T:.3f} s', f'$g$ = {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2' )) props = dict(boxstyle='round', facecolor='wheat', alpha=0.8) ax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=12, verticalalignment='top', bbox=props) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"\ud83d\udccf Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials-setup","text":"","title":"\ud83e\uddea Materials &amp; Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials-needed","text":"A string (~1 or 1.5 meters long) A small weight (e.g., bag of coins, sugar, or a keychain) A stopwatch or smartphone timer A ruler or measuring tape","title":"\u2705 Materials Needed"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Construct the Pendulum Attach the weight to one end of the string and secure the other end to a sturdy support, allowing it to swing freely. Measure Pendulum Length Measure the length \\(L\\) from the suspension point to the center of mass of the weight. Record this value carefully using a ruler or tape measure. Note Instrument Resolution Record the resolution of the measuring instrument (typically in centimeters or millimeters). Calculate Uncertainty in Length Measurement Use the formula: \\[\\Delta L=\\frac{\\text{Resolution of Ruler}}{2}\\] This represents the uncertainty due to the finite precision of your measuring tool. For example, if the smallest division is 1 mm, then: \\( \\(\\Delta L=\\frac{1\\,\\text{mm}}{2}=0.5\\,\\text{mm}=0.0005\\,\\text{m}\\) \\)","title":"\ud83d\udd27 Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#summary-of-setup-values-example-format","text":"Quantity Symbol Value Units Notes Pendulum Length \\(L\\) 1.200 m Measured from pivot to mass center Ruler Resolution \u2013 1 mm Smallest readable unit Uncertainty in \\(L\\) \\(\\Delta L\\) 0.0005 m \\(\\Delta L=\\frac{1}{2}\\,\\text{mm}\\)","title":"\ud83d\udccc Summary of Setup Values (Example Format)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"","title":"\u23f1\ufe0f Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Displace the pendulum to an angle less than \\(15^\\circ\\) and release it gently. Measure the time it takes for 10 full oscillations . Denote this time as \\(T_{10}\\) . Repeat the measurement a total of 10 times to collect a reliable data set.","title":"\ud83c\udf00 Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#record-measurements","text":"Collect and tabulate all 10 values of \\(T_{10}\\) . Use a table like the following: Trial \\(T_{10}\\) (s) 1 2 ... 10","title":"\ud83e\uddfe Record Measurements"},{"location":"1%20Physics/7%20Measurements/Problem_1/#statistical-analysis","text":"Calculate the mean time for 10 oscillations: \\[ \\overline{T}_{10} = \\frac{1}{n} \\sum_{i=1}^{n} T_{10}^{(i)} \\] where \\(n = 10\\) and \\(T_{10}^{(i)}\\) is the time from the \\(i^{\\text{th}}\\) trial. Compute the standard deviation of the \\(T_{10}\\) values: \\[ \\sigma_T = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} \\left(T_{10}^{(i)} - \\overline{T}_{10}\\right)^2} \\] Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\] This represents the standard error of the mean , which quantifies the precision of your mean timing result.","title":"\ud83d\udcca Statistical Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-output-table","text":"Quantity Symbol Formula Units Mean of 10 times \\(\\overline{T}_{10}\\) \\(\\frac{1}{n} \\sum T_{10}^{(i)}\\) s Standard deviation \\(\\sigma_T\\) \\(\\sqrt{\\frac{1}{n-1} \\sum (T_{10}-\\overline{T}_{10})^2}\\) s Uncertainty in mean \\(\\Delta T_{10}\\) \\(\\frac{\\sigma_T}{\\sqrt{n}}\\) s","title":"\ud83e\uddee Example Output Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"\ud83d\udcda Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-with-standard-value","text":"The experimentally determined value of gravitational acceleration is: \\[ g_{\\text{measured}} = \\frac{4\\pi^2 L}{T^2} \\] The standard accepted value is: \\[ g_{\\text{standard}} = 9.81\\, \\text{m/s}^2 \\] Compare the measured value of \\(g\\) with \\(9.81\\, \\text{m/s}^2\\) . If the two values agree within the uncertainty \\(\\Delta g\\) , the experiment can be considered successful. Consider the relative error: \\[ \\text{Relative Error} = \\frac{|g_{\\text{measured}} - g_{\\text{standard}}|}{g_{\\text{standard}}} \\times 100\\% \\]","title":"\u2705 Comparison with Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-discussion","text":"","title":"\ud83e\uddfe Uncertainty Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#effect-of-measurement-resolution-on-delta-l","text":"The uncertainty in length, \\(\\Delta L\\) , is directly related to the resolution of the measuring instrument : \\[ \\Delta L = \\frac{\\text{Resolution}}{2} \\] If the ruler has a coarse resolution (e.g., 1 cm), this increases \\(\\Delta L\\) , and in turn, increases the total uncertainty \\(\\Delta g\\) via: \\[ \\Delta g \\propto \\frac{\\Delta L}{L} \\] Better measuring tools (e.g., a caliper or laser ruler) would reduce \\(\\Delta L\\) and improve the accuracy of \\(g\\) .","title":"\ud83d\udd2c Effect of Measurement Resolution on \\(\\Delta L\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#impact-of-timing-variability-on-delta-t","text":"The time measurements are subjective if done manually, leading to random errors. Timing variability is quantified by the standard deviation \\(\\sigma_T\\) and the uncertainty in the mean: \\[ \\Delta T = \\frac{\\sigma_T}{\\sqrt{n} \\cdot 10} \\] This impacts the uncertainty in \\(g\\) quadratically: \\[ \\Delta g \\propto 2 \\cdot \\frac{\\Delta T}{T} \\] Using photogates or electronic timers would minimize this variability significantly.","title":"\u23f1\ufe0f Impact of Timing Variability on \\(\\Delta T\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#assumptions-and-limitations","text":"The angle of release is assumed to be small ( \\(< 15^\\circ\\) ) so that the pendulum follows simple harmonic motion . Air resistance and friction at the pivot are neglected . The string is assumed to be massless and inextensible . The center of mass of the bob is assumed to be clearly defined and accurately measurable . Human reaction time introduces systematic uncertainty in timing.","title":"\u26a0\ufe0f Assumptions and Limitations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"Ensure that the final reported value of \\(g\\) is written with its uncertainty : \\[ g = g_{\\text{measured}} \\pm \\Delta g \\quad \\text{(in m/s}^2\\text{)} \\] Evaluate whether this range includes the accepted value \\(9.81\\, \\text{m/s}^2\\) .","title":"\ud83d\udccc Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-codes","text":"# \u25b6\ufe0f Install required library (only needed once in Colab) !pip install -q pillow import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter # === Physics Constants === L = 1.2 # Pendulum length in meters theta_max = np.radians(15) # Max angular displacement g = 9.81 # Gravitational acceleration omega = np.sqrt(g / L) period = 2 * np.pi * np.sqrt(L / g) t_vals = np.linspace(0, 2 * period, 100) # === Set up figure and axis === fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.4, 1.4) ax.set_ylim(-1.6, 0.4) ax.set_aspect('equal') ax.axis('off') # Hide axes # === Pendulum Graphics === line, = ax.plot([], [], lw=3, color='#0077b6') bob = plt.Circle((0, -L), 0.06, color='#f72585', zorder=5) ax.add_patch(bob) # === Static Text Annotations (positioned safely outside swing) === length_label = ax.text(0, 0.3, \"$L = 1.2\\\\,\\\\mathrm{m}$\", fontsize=13, ha='center', bbox=dict(facecolor='wheat', edgecolor='black')) angle_label = ax.text(1.1, -1.3, \"\", fontsize=12, color='black', bbox=dict(facecolor='lightgray', edgecolor='gray')) # === Animation Function === def animate(i): t = t_vals[i] theta = theta_max * np.cos(omega * t) x = L * np.sin(theta) y = -L * np.cos(theta) # Update pendulum position line.set_data([0, x], [0, y]) bob.center = (x, y) # Update angle text angle_deg = np.degrees(theta) angle_label.set_text(f\"$\\\\theta = {angle_deg:.1f}^\\\\circ$\") return line, bob, angle_label # === Create Animation === ani = FuncAnimation(fig, animate, frames=len(t_vals), interval=50, blit=True) # Save as GIF gif_path = \"/content/pendulum_setup_clean.gif\" ani.save(gif_path, writer=PillowWriter(fps=20)) plt.close() # Display GIF from IPython.display import Image Image(filename=gif_path) import matplotlib.pyplot as plt import numpy as np # === \ud83d\udd22 Input Your Experimental Results === g_measured = 9.77 # replace with your measured g delta_g = 0.10 # replace with your uncertainty in g g_standard = 9.81 # standard gravity # === \u2699\ufe0f Data Setup === positions = [0, 1] labels = ['Measured $g$', 'Standard $g$'] values = [g_measured, g_standard] errors = [delta_g, 0] # Only measured g has uncertainty colors = ['#00b4d8', '#90be6d'] # measured and standard # === \ud83d\udcca Create Plot === fig, ax = plt.subplots(figsize=(10, 6)) bars = ax.bar( positions, values, yerr=errors, capsize=10, color=colors, edgecolor='black', alpha=0.9 ) # === \ud83d\udccd Annotate Bars === ax.text( positions[0], g_measured + delta_g + 0.1, f\"$g_{{measured}} = {g_measured:.2f} \\pm {delta_g:.2f}$ m/s\u00b2\", ha='center', fontsize=12, bbox=dict(boxstyle=\"round,pad=0.4\", fc=\"#ffd6a5\", ec=\"black\", alpha=0.85) ) ax.text( positions[1], g_standard + 0.1, f\"$g_{{standard}} = {g_standard:.2f}$ m/s\u00b2\", ha='center', fontsize=12, bbox=dict(boxstyle=\"round,pad=0.4\", fc=\"#d0f4de\", ec=\"black\", alpha=0.85) ) # === \ud83d\udcd8 Additional Explanation === ax.annotate( \"Uncertainty range\\n(\u00b1 \u0394g)\", xy=(0, g_measured + delta_g), xytext=(0.1, g_measured + delta_g + 0.6), arrowprops=dict(arrowstyle=\"->\", color='black'), fontsize=11, bbox=dict(boxstyle=\"round\", fc=\"#fefae0\", ec=\"gray\", alpha=0.9) ) # === \ud83c\udfa8 Styling === ax.set_title(\"\ud83c\udf0d Comparison of Measured vs Standard Gravitational Acceleration\", fontsize=16, weight='bold') ax.set_ylabel(\"Gravitational Acceleration (m/s\u00b2)\", fontsize=13) ax.set_xticks(positions) ax.set_xticklabels(labels, fontsize=12) ax.set_ylim(0, max(g_measured + delta_g, g_standard) + 1) # Add horizontal reference line ax.axhline(g_standard, color='#6a994e', linestyle='--', linewidth=1.5, alpha=0.7) # Grid ax.yaxis.grid(True, linestyle='--', alpha=0.5) # Final layout plt.tight_layout() plt.show() # \u2705 Pendulum Gravity Measurement Tool with Beautiful Plot import numpy as np import matplotlib.pyplot as plt # \ud83d\udce5 Your 10 measurements of T_10 (in seconds) T_10_measurements = np.array([21.40, 21.52, 21.47, 21.35, 21.60, 21.43, 21.50, 21.44, 21.38, 21.46]) # \u2699\ufe0f Constants n = len(T_10_measurements) ruler_resolution_mm = 1.0 # mm L = 1.200 # pendulum length in meters delta_L = (ruler_resolution_mm / 1000) / 2 # Convert mm to m, divide by 2 # \ud83d\udcca Stats calculations T10_mean = np.mean(T_10_measurements) sigma_T = np.std(T_10_measurements, ddof=1) delta_T10 = sigma_T / np.sqrt(n) T = T10_mean / 10 delta_T = delta_T10 / 10 g = (4 * np.pi**2 * L) / (T**2) delta_g = g * np.sqrt((delta_L / L)**2 + (2 * delta_T / T)**2) # \ud83d\udda8\ufe0f Results print(\"=== Results ===\") print(f\"Mean T_10 = {T10_mean:.4f} s\") print(f\"Standard deviation \u03c3_T = {sigma_T:.4f} s\") print(f\"Uncertainty in mean \u0394T_10 = {delta_T10:.4f} s\") print(f\"Single period T = {T:.4f} \u00b1 {delta_T:.4f} s\") print(f\"g = {g:.4f} \u00b1 {delta_g:.4f} m/s\u00b2\") # \ud83c\udfa8 Plot fig, ax = plt.subplots(figsize=(10, 6)) x = np.arange(1, n + 1) # Error bars and points ax.errorbar(x, T_10_measurements, yerr=delta_T10, fmt='o', color='teal', ecolor='salmon', elinewidth=2, capsize=5, label='T\u2081\u2080 Measurements') # Mean line ax.axhline(T10_mean, color='orange', linestyle='--', linewidth=2, label=f'Mean = {T10_mean:.2f} s') # Labels and Title ax.set_title(\"Pendulum Timing Measurements ($T_{10}$)\", fontsize=16, weight='bold') ax.set_xlabel(\"Trial Number\", fontsize=13) ax.set_ylabel(\"Time for 10 Oscillations (s)\", fontsize=13) ax.grid(True, linestyle='--', alpha=0.5) ax.legend(fontsize=12) # Annotation box textstr = '\\n'.join(( f'$\\overline{{T_{{10}}}}$ = {T10_mean:.2f} s', f'$\\sigma_T$ = {sigma_T:.3f} s', f'$\\\\Delta T_{{10}}$ = {delta_T10:.3f} s', f'$T$ = {T:.3f} s \u00b1 {delta_T:.3f} s', f'$g$ = {g:.3f} \u00b1 {delta_g:.3f} m/s\u00b2' )) props = dict(boxstyle='round', facecolor='wheat', alpha=0.8) ax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=12, verticalalignment='top', bbox=props) plt.tight_layout() plt.show()","title":"Python Codes"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}